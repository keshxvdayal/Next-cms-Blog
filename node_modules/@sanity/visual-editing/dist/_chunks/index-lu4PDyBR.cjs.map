{"version":3,"file":"index-lu4PDyBR.cjs","sources":["../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/rng.js","../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/stringify.js","../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/native.js","../../../../node_modules/.pnpm/uuid@9.0.1/node_modules/uuid/dist/esm-browser/v4.js","../../../../node_modules/.pnpm/@sanity+client@6.12.4/node_modules/@sanity/client/dist/_chunks/resolveEditInfo-uXvm6eWd.js","../../../../node_modules/.pnpm/valibot@0.28.1/node_modules/valibot/dist/index.js","../../../visual-editing-helpers/dist/_chunks/urlStringToPath-53ZuVkUF.js","../../../visual-editing-helpers/dist/csm.js","../../src/constants.ts","../../src/util/findNonInlineElement.ts","../../src/util/stega.ts","../../src/util/findSanityNodes.ts","../../src/util/getRect.ts","../../src/ui/enableVisualEditing.tsx","../../src/controller.ts"],"sourcesContent":["// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","const rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\nconst reKeySegment = /_key\\s*==\\s*['\"](.*)['\"]/;\nconst reIndexTuple = /^\\d*:\\d*$/;\nfunction isIndexSegment(segment) {\n  return typeof segment === \"number\" || typeof segment === \"string\" && /^\\[\\d+\\]$/.test(segment);\n}\nfunction isKeySegment(segment) {\n  if (typeof segment === \"string\") {\n    return reKeySegment.test(segment.trim());\n  }\n  return typeof segment === \"object\" && \"_key\" in segment;\n}\nfunction isIndexTuple(segment) {\n  if (typeof segment === \"string\" && reIndexTuple.test(segment)) {\n    return true;\n  }\n  if (!Array.isArray(segment) || segment.length !== 2) {\n    return false;\n  }\n  const [from, to] = segment;\n  return (typeof from === \"number\" || from === \"\") && (typeof to === \"number\" || to === \"\");\n}\nfunction get(obj, path, defaultVal) {\n  const select = typeof path === \"string\" ? fromString(path) : path;\n  if (!Array.isArray(select)) {\n    throw new Error(\"Path must be an array or a string\");\n  }\n  let acc = obj;\n  for (let i = 0; i < select.length; i++) {\n    const segment = select[i];\n    if (isIndexSegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal;\n      }\n      acc = acc[segment];\n    }\n    if (isKeySegment(segment)) {\n      if (!Array.isArray(acc)) {\n        return defaultVal;\n      }\n      acc = acc.find((item) => item._key === segment._key);\n    }\n    if (typeof segment === \"string\") {\n      acc = typeof acc === \"object\" && acc !== null ? acc[segment] : void 0;\n    }\n    if (typeof acc === \"undefined\") {\n      return defaultVal;\n    }\n  }\n  return acc;\n}\nfunction toString(path) {\n  if (!Array.isArray(path)) {\n    throw new Error(\"Path is not an array\");\n  }\n  return path.reduce((target, segment, i) => {\n    const segmentType = typeof segment;\n    if (segmentType === \"number\") {\n      return \"\".concat(target, \"[\").concat(segment, \"]\");\n    }\n    if (segmentType === \"string\") {\n      const separator = i === 0 ? \"\" : \".\";\n      return \"\".concat(target).concat(separator).concat(segment);\n    }\n    if (isKeySegment(segment) && segment._key) {\n      return \"\".concat(target, '[_key==\"').concat(segment._key, '\"]');\n    }\n    if (Array.isArray(segment)) {\n      const [from, to] = segment;\n      return \"\".concat(target, \"[\").concat(from, \":\").concat(to, \"]\");\n    }\n    throw new Error(\"Unsupported path segment `\".concat(JSON.stringify(segment), \"`\"));\n  }, \"\");\n}\nfunction fromString(path) {\n  if (typeof path !== \"string\") {\n    throw new Error(\"Path is not a string\");\n  }\n  const segments = path.match(rePropName);\n  if (!segments) {\n    throw new Error(\"Invalid path string\");\n  }\n  return segments.map(parsePathSegment);\n}\nfunction parsePathSegment(segment) {\n  if (isIndexSegment(segment)) {\n    return parseIndexSegment(segment);\n  }\n  if (isKeySegment(segment)) {\n    return parseKeySegment(segment);\n  }\n  if (isIndexTuple(segment)) {\n    return parseIndexTupleSegment(segment);\n  }\n  return segment;\n}\nfunction parseIndexSegment(segment) {\n  return Number(segment.replace(/[^\\d]/g, \"\"));\n}\nfunction parseKeySegment(segment) {\n  const segments = segment.match(reKeySegment);\n  return { _key: segments[1] };\n}\nfunction parseIndexTupleSegment(segment) {\n  const [from, to] = segment.split(\":\").map((seg) => seg === \"\" ? seg : Number(seg));\n  return [from, to];\n}\n\nvar studioPath = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  fromString: fromString,\n  get: get,\n  isIndexSegment: isIndexSegment,\n  isIndexTuple: isIndexTuple,\n  isKeySegment: isKeySegment,\n  reKeySegment: reKeySegment,\n  toString: toString\n});\n\nconst DRAFTS_PREFIX = \"drafts.\";\nfunction getPublishedId(id) {\n  if (id.startsWith(DRAFTS_PREFIX)) {\n    return id.slice(DRAFTS_PREFIX.length);\n  }\n  return id;\n}\n\nconst ESCAPE = {\n  \"\\f\": \"\\\\f\",\n  \"\\n\": \"\\\\n\",\n  \"\\r\": \"\\\\r\",\n  \"\t\": \"\\\\t\",\n  \"'\": \"\\\\'\",\n  \"\\\\\": \"\\\\\\\\\"\n};\nconst UNESCAPE = {\n  \"\\\\f\": \"\\f\",\n  \"\\\\n\": \"\\n\",\n  \"\\\\r\": \"\\r\",\n  \"\\\\t\": \"\t\",\n  \"\\\\'\": \"'\",\n  \"\\\\\\\\\": \"\\\\\"\n};\nfunction jsonPath(path) {\n  return \"$\".concat(path.map((segment) => {\n    if (typeof segment === \"string\") {\n      const escapedKey = segment.replace(/[\\f\\n\\r\\t'\\\\]/g, (match) => {\n        return ESCAPE[match];\n      });\n      return \"['\".concat(escapedKey, \"']\");\n    }\n    if (typeof segment === \"number\") {\n      return \"[\".concat(segment, \"]\");\n    }\n    if (segment._key !== \"\") {\n      const escapedKey = segment._key.replace(/['\\\\]/g, (match) => {\n        return ESCAPE[match];\n      });\n      return \"[?(@._key=='\".concat(escapedKey, \"')]\");\n    }\n    return \"[\".concat(segment._index, \"]\");\n  }).join(\"\"));\n}\nfunction parseJsonPath(path) {\n  const parsed = [];\n  const parseRe = /\\['(.*?)'\\]|\\[(\\d+)\\]|\\[\\?\\(@\\._key=='(.*?)'\\)\\]/g;\n  let match;\n  while ((match = parseRe.exec(path)) !== null) {\n    if (match[1] !== void 0) {\n      const key = match[1].replace(/\\\\(\\\\|f|n|r|t|')/g, (m) => {\n        return UNESCAPE[m];\n      });\n      parsed.push(key);\n      continue;\n    }\n    if (match[2] !== void 0) {\n      parsed.push(parseInt(match[2], 10));\n      continue;\n    }\n    if (match[3] !== void 0) {\n      const _key = match[3].replace(/\\\\(\\\\')/g, (m) => {\n        return UNESCAPE[m];\n      });\n      parsed.push({\n        _key,\n        _index: -1\n      });\n      continue;\n    }\n  }\n  return parsed;\n}\nfunction jsonPathToStudioPath(path) {\n  return path.map((segment) => {\n    if (typeof segment === \"string\") {\n      return segment;\n    }\n    if (typeof segment === \"number\") {\n      return segment;\n    }\n    if (segment._key !== \"\") {\n      return { _key: segment._key };\n    }\n    if (segment._index !== -1) {\n      return segment._index;\n    }\n    throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n  });\n}\nfunction studioPathToJsonPath(path) {\n  const parsedPath = typeof path === \"string\" ? fromString(path) : path;\n  return parsedPath.map((segment) => {\n    if (typeof segment === \"string\") {\n      return segment;\n    }\n    if (typeof segment === \"number\") {\n      return segment;\n    }\n    if (Array.isArray(segment)) {\n      throw new Error(\"IndexTuple segments aren't supported:\".concat(JSON.stringify(segment)));\n    }\n    if (isContentSourceMapParsedPathKeyedSegment(segment)) {\n      return segment;\n    }\n    if (segment._key) {\n      return { _key: segment._key, _index: -1 };\n    }\n    throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n  });\n}\nfunction isContentSourceMapParsedPathKeyedSegment(segment) {\n  return typeof segment === \"object\" && \"_key\" in segment && \"_index\" in segment;\n}\nfunction jsonPathToMappingPath(path) {\n  return path.map((segment) => {\n    if (typeof segment === \"string\") {\n      return segment;\n    }\n    if (typeof segment === \"number\") {\n      return segment;\n    }\n    if (segment._index !== -1) {\n      return segment._index;\n    }\n    throw new Error(\"invalid segment:\".concat(JSON.stringify(segment)));\n  });\n}\n\nfunction resolveMapping(resultPath, csm) {\n  if (!(csm == null ? void 0 : csm.mappings)) {\n    return void 0;\n  }\n  const resultMappingPath = jsonPath(jsonPathToMappingPath(resultPath));\n  if (csm.mappings[resultMappingPath] !== void 0) {\n    return {\n      mapping: csm.mappings[resultMappingPath],\n      matchedPath: resultMappingPath,\n      pathSuffix: \"\"\n    };\n  }\n  const mappings = Object.entries(csm.mappings).filter(([key]) => resultMappingPath.startsWith(key)).sort(([key1], [key2]) => key2.length - key1.length);\n  if (mappings.length == 0) {\n    return void 0;\n  }\n  const [matchedPath, mapping] = mappings[0];\n  const pathSuffix = resultMappingPath.substring(matchedPath.length);\n  return { mapping, matchedPath, pathSuffix };\n}\n\nfunction isArray(value) {\n  return value !== null && Array.isArray(value);\n}\n\nfunction isRecord(value) {\n  return typeof value === \"object\" && value !== null;\n}\n\nfunction walkMap(value, mappingFn, path = []) {\n  if (isArray(value)) {\n    return value.map((v, idx) => {\n      if (isRecord(v)) {\n        const _key = v[\"_key\"];\n        if (typeof _key === \"string\") {\n          return walkMap(v, mappingFn, path.concat({ _key, _index: idx }));\n        }\n      }\n      return walkMap(v, mappingFn, path.concat(idx));\n    });\n  }\n  if (isRecord(value)) {\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [k, walkMap(v, mappingFn, path.concat(k))])\n    );\n  }\n  return mappingFn(value, path);\n}\n\nfunction createEditUrl(options) {\n  const {\n    baseUrl,\n    workspace: _workspace = \"default\",\n    tool: _tool = \"default\",\n    id: _id,\n    type,\n    path\n  } = options;\n  if (!baseUrl) {\n    throw new Error(\"baseUrl is required\");\n  }\n  if (!path) {\n    throw new Error(\"path is required\");\n  }\n  if (!_id) {\n    throw new Error(\"id is required\");\n  }\n  if (baseUrl !== \"/\" && baseUrl.endsWith(\"/\")) {\n    throw new Error(\"baseUrl must not end with a slash\");\n  }\n  const workspace = _workspace === \"default\" ? void 0 : _workspace;\n  const tool = _tool === \"default\" ? void 0 : _tool;\n  const id = getPublishedId(_id);\n  const stringifiedPath = Array.isArray(path) ? toString(jsonPathToStudioPath(path)) : path;\n  const searchParams = new URLSearchParams({\n    baseUrl,\n    id,\n    type,\n    path: stringifiedPath\n  });\n  if (workspace) {\n    searchParams.set(\"workspace\", workspace);\n  }\n  if (tool) {\n    searchParams.set(\"tool\", tool);\n  }\n  const segments = [baseUrl === \"/\" ? \"\" : baseUrl];\n  if (workspace) {\n    segments.push(workspace);\n  }\n  const routerParams = [\n    \"mode=presentation\",\n    \"id=\".concat(id),\n    \"type=\".concat(type),\n    \"path=\".concat(encodeURIComponent(stringifiedPath))\n  ];\n  if (tool) {\n    routerParams.push(\"tool=\".concat(tool));\n  }\n  segments.push(\"intent\", \"edit\", \"\".concat(routerParams.join(\";\"), \"?\").concat(searchParams));\n  return segments.join(\"/\");\n}\n\nfunction resolveEditInfo(options) {\n  const { resultSourceMap: csm, resultPath } = options;\n  const { mapping, pathSuffix } = resolveMapping(resultPath, csm) || {};\n  if (!mapping) {\n    return void 0;\n  }\n  if (mapping.source.type === \"literal\") {\n    return void 0;\n  }\n  if (mapping.source.type === \"unknown\") {\n    return void 0;\n  }\n  const sourceDoc = csm.documents[mapping.source.document];\n  const sourcePath = csm.paths[mapping.source.path];\n  if (sourceDoc && sourcePath) {\n    const { baseUrl, workspace, tool } = resolveStudioBaseRoute(\n      typeof options.studioUrl === \"function\" ? options.studioUrl(sourceDoc) : options.studioUrl\n    );\n    if (!baseUrl)\n      return void 0;\n    const { _id, _type } = sourceDoc;\n    return {\n      baseUrl,\n      workspace,\n      tool,\n      id: _id,\n      type: _type,\n      path: parseJsonPath(sourcePath + pathSuffix)\n    };\n  }\n  return void 0;\n}\nfunction resolveStudioBaseRoute(studioUrl) {\n  let baseUrl = typeof studioUrl === \"string\" ? studioUrl : studioUrl.baseUrl;\n  if (baseUrl !== \"/\") {\n    baseUrl = baseUrl.replace(/\\/$/, \"\");\n  }\n  if (typeof studioUrl === \"string\") {\n    return { baseUrl };\n  }\n  return { ...studioUrl, baseUrl };\n}\n\nexport { DRAFTS_PREFIX, createEditUrl, get, getPublishedId, jsonPath, jsonPathToStudioPath, parseJsonPath, reKeySegment, resolveEditInfo, resolveMapping, resolveStudioBaseRoute, studioPath, studioPathToJsonPath, toString, walkMap };\n//# sourceMappingURL=resolveEditInfo-uXvm6eWd.js.map\n","// src/error/flatten/flatten.ts\nfunction flatten(arg1) {\n  return (Array.isArray(arg1) ? arg1 : arg1.issues).reduce(\n    (flatErrors, issue) => {\n      if (issue.path) {\n        if (issue.path.every(\n          ({ key }) => typeof key === \"string\" || typeof key === \"number\"\n        )) {\n          const path = issue.path.map(({ key }) => key).join(\".\");\n          if (flatErrors.nested[path]) {\n            flatErrors.nested[path].push(issue.message);\n          } else {\n            flatErrors.nested[path] = [issue.message];\n          }\n        }\n      } else {\n        if (flatErrors.root) {\n          flatErrors.root.push(issue.message);\n        } else {\n          flatErrors.root = [issue.message];\n        }\n      }\n      return flatErrors;\n    },\n    { nested: {} }\n  );\n}\n\n// src/error/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/methods/brand/brand.ts\nvar BrandSymbol = Symbol(\"brand\");\nfunction brand(schema, name) {\n  return schema;\n}\n\n// src/methods/coerce/coerce.ts\nfunction coerce(schema, action) {\n  return {\n    ...schema,\n    _parse(input, config) {\n      return schema._parse(action(input), config);\n    }\n  };\n}\n\n// src/methods/coerce/coerceAsync.ts\nfunction coerceAsync(schema, action) {\n  return {\n    ...schema,\n    async _parse(input, config) {\n      return schema._parse(await action(input), config);\n    }\n  };\n}\n\n// src/utils/actionIssue/actionIssue.ts\nfunction actionIssue(context, reference, input, label, received) {\n  return {\n    issues: [{ context, reference, input, label, received }]\n  };\n}\n\n// src/utils/actionOutput/actionOutput.ts\nfunction actionOutput(output) {\n  return { output };\n}\n\n// src/utils/defaultArgs/defaultArgs.ts\nfunction defaultArgs(arg1, arg2) {\n  return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];\n}\n\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config) {\n  store = { ...store, ...config };\n}\nfunction getGlobalConfig(config) {\n  return {\n    lang: config?.lang ?? store?.lang,\n    message: config?.message,\n    abortEarly: config?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config?.abortPipeEarly ?? store?.abortPipeEarly,\n    skipPipe: config?.skipPipe ?? store?.skipPipe\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2)\n    store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3)\n    store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4)\n    store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference))\n    store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/i18n/i18n.ts\nfunction i18n(context, reference, config, issue) {\n  const message = context.message ?? getSpecificMessage(reference, issue.lang) ?? (context.type === \"type\" ? getSchemaMessage(issue.lang) : null) ?? config?.message ?? getGlobalMessage(issue.lang) ?? issue.message;\n  return typeof message === \"function\" ? message(issue) : message;\n}\n\n// src/utils/isLuhnAlgo/isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/schemaResult/schemaResult.ts\nfunction schemaResult(typed, output, issues) {\n  return { typed, output, issues };\n}\n\n// src/utils/stringify/stringify.ts\nfunction stringify(input) {\n  let type = typeof input;\n  if (type === \"object\") {\n    type = input ? Object.getPrototypeOf(input).constructor.name : \"null\";\n  }\n  return type === \"string\" ? `\"${input}\"` : type === \"number\" || type === \"bigint\" || type === \"boolean\" ? `${input}` : type;\n}\n\n// src/utils/pipeResult/utils/pipeIssue/pipeIssue.ts\nfunction pipeIssue(context, config, issue) {\n  const received = issue.received ?? stringify(issue.input);\n  const schemaIssue2 = {\n    reason: context.type,\n    context: issue.context.type,\n    expected: issue.context.expects,\n    received,\n    message: `Invalid ${issue.label}: ${issue.context.expects ? `Expected ${issue.context.expects} but r` : \"R\"}eceived ${received}`,\n    input: issue.input,\n    requirement: issue.context.requirement,\n    path: issue.path,\n    lang: config?.lang,\n    abortEarly: config?.abortEarly,\n    abortPipeEarly: config?.abortPipeEarly,\n    skipPipe: config?.skipPipe\n  };\n  schemaIssue2.message = i18n(\n    issue.context,\n    issue.reference,\n    config,\n    schemaIssue2\n  );\n  return schemaIssue2;\n}\n\n// src/utils/pipeResult/pipeResult.ts\nfunction pipeResult(context, input, config, issues) {\n  if (context.pipe && !config?.skipPipe) {\n    for (const action of context.pipe) {\n      const result = action._parse(input);\n      if (result.issues) {\n        for (const actionIssue2 of result.issues) {\n          const schemaIssue2 = pipeIssue(context, config, actionIssue2);\n          issues ? issues.push(schemaIssue2) : issues = [schemaIssue2];\n        }\n        if (config?.abortEarly || config?.abortPipeEarly) {\n          break;\n        }\n      } else {\n        input = result.output;\n      }\n    }\n  }\n  return schemaResult(true, input, issues);\n}\n\n// src/utils/pipeResult/pipeResultAsync.ts\nasync function pipeResultAsync(context, input, config, issues) {\n  if (context.pipe && !config?.skipPipe) {\n    for (const action of context.pipe) {\n      const result = await action._parse(input);\n      if (result.issues) {\n        for (const actionIssue2 of result.issues) {\n          const schemaIssue2 = pipeIssue(context, config, actionIssue2);\n          issues ? issues.push(schemaIssue2) : issues = [schemaIssue2];\n        }\n        if (config?.abortEarly || config?.abortPipeEarly) {\n          break;\n        }\n      } else {\n        input = result.output;\n      }\n    }\n  }\n  return schemaResult(true, input, issues);\n}\n\n// src/utils/restAndDefaultArgs/restAndDefaultArgs.ts\nfunction restAndDefaultArgs(arg1, arg2, arg3) {\n  if (!arg1 || typeof arg1 === \"object\" && !Array.isArray(arg1)) {\n    const [error2, pipe2] = defaultArgs(arg2, arg3);\n    return [arg1, error2, pipe2];\n  }\n  const [error, pipe] = defaultArgs(\n    arg1,\n    arg2\n  );\n  return [void 0, error, pipe];\n}\n\n// src/utils/schemaIssue/schemaIssue.ts\nfunction schemaIssue(context, reference, input, config, other) {\n  const received = stringify(input);\n  const expected = other?.expected ?? context.expects;\n  const issue = {\n    reason: other?.reason ?? \"type\",\n    context: context.type,\n    expected,\n    received,\n    message: `Invalid type: Expected ${expected} but received ${received}`,\n    input,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config?.lang,\n    abortEarly: config?.abortEarly,\n    abortPipeEarly: config?.abortPipeEarly,\n    skipPipe: config?.skipPipe\n  };\n  issue.message = i18n(context, reference, config, issue);\n  return { typed: false, output: input, issues: [issue] };\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, info) {\n  return typeof schema.fallback === \"function\" ? schema.fallback(info) : schema.fallback;\n}\n\n// src/methods/getFallback/getFallbackAsync.ts\nasync function getFallbackAsync(schema, info) {\n  return typeof schema.fallback === \"function\" ? await schema.fallback(info) : schema.fallback;\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _parse(input, config) {\n      const result = schema._parse(input, config);\n      return result.issues ? schemaResult(\n        true,\n        getFallback(this, { input, issues: result.issues })\n      ) : result;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async _parse(input, config) {\n      const result = await schema._parse(input, config);\n      return result.issues ? schemaResult(\n        true,\n        await getFallbackAsync(this, { input, issues: result.issues })\n      ) : result;\n    }\n  };\n}\n\n// src/methods/forward/forward.ts\nfunction forward(validation, pathList) {\n  return {\n    ...validation,\n    _parse(input) {\n      const result = validation._parse(input);\n      if (result.issues) {\n        for (const issue of result.issues) {\n          let pathInput = input;\n          for (const key of pathList) {\n            const pathValue = pathInput[key];\n            issue.input = pathValue;\n            const pathItem = {\n              type: \"unknown\",\n              origin: \"value\",\n              input: pathInput,\n              key,\n              value: pathValue\n            };\n            issue.path ? issue.path.push(pathItem) : issue.path = [pathItem];\n            if (!pathValue) {\n              break;\n            }\n            pathInput = pathValue;\n          }\n        }\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\nfunction forwardAsync(validation, pathList) {\n  return {\n    ...validation,\n    async _parse(input) {\n      const result = await validation._parse(input);\n      if (result.issues) {\n        for (const issue of result.issues) {\n          let pathInput = input;\n          for (const key of pathList) {\n            const pathValue = pathInput[key];\n            issue.input = pathValue;\n            const pathItem = {\n              type: \"unknown\",\n              origin: \"value\",\n              input: pathInput,\n              key,\n              value: pathValue\n            };\n            issue.path ? issue.path.push(pathItem) : issue.path = [pathItem];\n            if (!pathValue) {\n              break;\n            }\n            pathInput = pathValue;\n          }\n        }\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema) {\n  return typeof schema.default === \"function\" ? schema.default() : schema.default;\n}\n\n// src/methods/getDefault/getDefaultAsync.ts\nasync function getDefaultAsync(schema) {\n  return typeof schema.default === \"function\" ? await schema.default() : schema.default;\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  let defaults;\n  if (schema.default !== void 0) {\n    defaults = getDefault(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      defaults = {};\n      for (const key in schema.entries) {\n        defaults[key] = getDefaults(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      defaults = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        defaults.push(getDefaults(schema.items[key]));\n      }\n    }\n  }\n  return defaults;\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  let defaults;\n  if (schema.default !== void 0) {\n    defaults = await getDefaultAsync(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      defaults = {};\n      for (const key in schema.entries) {\n        defaults[key] = await getDefaultsAsync(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      defaults = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        defaults.push(await getDefaultsAsync(schema.items[key]));\n      }\n    }\n  }\n  return defaults;\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  let fallbacks;\n  if (schema.fallback !== void 0) {\n    fallbacks = getFallback(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      fallbacks = {};\n      for (const key in schema.entries) {\n        fallbacks[key] = getFallbacks(schema.entries[key]);\n      }\n    } else if (schema.type === \"tuple\") {\n      fallbacks = [];\n      for (let key = 0; key < schema.items.length; key++) {\n        fallbacks.push(getFallbacks(schema.items[key]));\n      }\n    }\n  }\n  return fallbacks;\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  let fallbacks;\n  if (schema.fallback !== void 0) {\n    fallbacks = await getFallbackAsync(schema);\n  } else if (\"type\" in schema) {\n    if (schema.type === \"object\") {\n      fallbacks = {};\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, schema2]) => {\n          fallbacks[key] = await getFallbacksAsync(schema2);\n        })\n      );\n    } else if (schema.type === \"tuple\") {\n      fallbacks = await Promise.all(\n        schema.items.map((schema2) => getFallbacksAsync(schema2))\n      );\n    }\n  }\n  return fallbacks;\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input, config) {\n  return !schema._parse(input, {\n    abortEarly: true,\n    skipPipe: getGlobalConfig(config)?.skipPipe\n  }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any(pipe) {\n  return {\n    type: \"any\",\n    expects: \"any\",\n    async: false,\n    pipe,\n    _parse(input, config) {\n      return pipeResult(this, input, config);\n    }\n  };\n}\n\n// src/schemas/any/anyAsync.ts\nfunction anyAsync(pipe) {\n  return {\n    type: \"any\",\n    expects: \"any\",\n    async: true,\n    pipe,\n    async _parse(input, config) {\n      return pipeResultAsync(this, input, config);\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"array\",\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (Array.isArray(input)) {\n        let typed = true;\n        let issues;\n        const output = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const result = this.item._parse(value2, config);\n          if (result.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!result.typed) {\n            typed = false;\n          }\n          output.push(result.output);\n        }\n        if (typed) {\n          return pipeResult(this, output, config, issues);\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, array, input, config);\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"array\",\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (Array.isArray(input)) {\n        let typed = true;\n        let issues;\n        const output = [];\n        await Promise.all(\n          input.map(async (value2, key) => {\n            if (!(config?.abortEarly && issues)) {\n              const result = await this.item._parse(value2, config);\n              if (!(config?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"array\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (config?.abortEarly) {\n                    typed = false;\n                    throw null;\n                  }\n                }\n                if (!result.typed) {\n                  typed = false;\n                }\n                output[key] = result.output;\n              }\n            }\n          })\n        ).catch(() => null);\n        if (typed) {\n          return pipeResultAsync(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, arrayAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"bigint\",\n    expects: \"bigint\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (typeof input === \"bigint\") {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, bigint, input, config);\n    }\n  };\n}\n\n// src/schemas/bigint/bigintAsync.ts\nfunction bigintAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"bigint\",\n    expects: \"bigint\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (typeof input === \"bigint\") {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, bigintAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"blob\",\n    expects: \"Blob\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input instanceof Blob) {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, blob, input, config);\n    }\n  };\n}\n\n// src/schemas/blob/blobAsync.ts\nfunction blobAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"blob\",\n    expects: \"Blob\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input instanceof Blob) {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, blobAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"boolean\",\n    expects: \"boolean\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (typeof input === \"boolean\") {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, boolean, input, config);\n    }\n  };\n}\n\n// src/schemas/boolean/booleanAsync.ts\nfunction booleanAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"boolean\",\n    expects: \"boolean\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (typeof input === \"boolean\") {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, booleanAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"date\",\n    expects: \"Date\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input instanceof Date && !isNaN(input.getTime())) {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, date, input, config);\n    }\n  };\n}\n\n// src/schemas/date/dateAsync.ts\nfunction dateAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"date\",\n    expects: \"Date\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input instanceof Date && !isNaN(input.getTime())) {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, dateAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum__, message) {\n  const values = Object.values(enum__);\n  return {\n    type: \"enum\",\n    expects: values.map(stringify).join(\" | \"),\n    async: false,\n    enum: enum__,\n    message,\n    _parse(input, config) {\n      if (values.includes(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, enum_, input, config);\n    }\n  };\n}\nvar nativeEnum = enum_;\n\n// src/schemas/enum/enumAsync.ts\nfunction enumAsync(enum_2, message) {\n  const values = Object.values(enum_2);\n  return {\n    type: \"enum\",\n    expects: values.map(stringify).join(\" | \"),\n    async: true,\n    enum: enum_2,\n    message,\n    async _parse(input, config) {\n      if (values.includes(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, enumAsync, input, config);\n    }\n  };\n}\nvar nativeEnumAsync = enumAsync;\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"instance\",\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input instanceof this.class) {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, instance, input, config);\n    }\n  };\n}\n\n// src/schemas/instance/instanceAsync.ts\nfunction instanceAsync(class_, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"instance\",\n    expects: class_.name,\n    async: true,\n    class: class_,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input instanceof this.class) {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, instanceAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/intersect/utils/mergeOutputs/mergeOutputs.ts\nfunction mergeOutputs(output1, output2) {\n  if (typeof output1 === typeof output2) {\n    if (output1 === output2 || output1 instanceof Date && output2 instanceof Date && +output1 === +output2) {\n      return { output: output1 };\n    }\n    if (Array.isArray(output1) && Array.isArray(output2)) {\n      if (output1.length === output2.length) {\n        const array2 = [];\n        for (let index = 0; index < output1.length; index++) {\n          const result = mergeOutputs(output1[index], output2[index]);\n          if (result.invalid) {\n            return result;\n          }\n          array2.push(result.output);\n        }\n        return { output: array2 };\n      }\n      return { invalid: true };\n    }\n    if (output1 && output2 && output1.constructor === Object && output2.constructor === Object) {\n      const object2 = { ...output1, ...output2 };\n      for (const key in output1) {\n        if (key in output2) {\n          const result = mergeOutputs(output1[key], output2[key]);\n          if (result.invalid) {\n            return result;\n          }\n          object2[key] = result.output;\n        }\n      }\n      return { output: object2 };\n    }\n  }\n  return { invalid: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"intersect\",\n    expects: [...new Set(options.map((option) => option.expects))].join(\" & \"),\n    async: false,\n    options,\n    message,\n    pipe,\n    _parse(input, config) {\n      let typed = true;\n      let issues;\n      let output;\n      const outputs = [];\n      for (const schema of this.options) {\n        const result = schema._parse(input, config);\n        if (result.issues) {\n          if (issues) {\n            for (const issue of result.issues) {\n              issues.push(issue);\n            }\n          } else {\n            issues = result.issues;\n          }\n          if (config?.abortEarly) {\n            typed = false;\n            break;\n          }\n        }\n        if (!result.typed) {\n          typed = false;\n        }\n        outputs.push(result.output);\n      }\n      if (typed) {\n        output = outputs[0];\n        for (let index = 1; index < outputs.length; index++) {\n          const result = mergeOutputs(output, outputs[index]);\n          if (result.invalid) {\n            return schemaIssue(this, intersect, input, config);\n          }\n          output = result.output;\n        }\n        return pipeResult(this, output, config, issues);\n      }\n      return schemaResult(false, output, issues);\n    }\n  };\n}\nvar intersection = intersect;\n\n// src/schemas/literal/literal.ts\nfunction literal(literal_, message) {\n  return {\n    type: \"literal\",\n    expects: stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    _parse(input, config) {\n      if (input === this.literal) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, literal, input, config);\n    }\n  };\n}\n\n// src/schemas/literal/literalAsync.ts\nfunction literalAsync(literal2, message) {\n  return {\n    type: \"literal\",\n    expects: stringify(literal2),\n    async: true,\n    literal: literal2,\n    message,\n    async _parse(input, config) {\n      if (input === this.literal) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, literalAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, arg3, arg4) {\n  const [message, pipe] = defaultArgs(arg3, arg4);\n  return {\n    type: \"map\",\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input instanceof Map) {\n        let typed = true;\n        let issues;\n        const output = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input.entries()) {\n          let pathItem;\n          const keyResult = this.key._parse(inputKey, config);\n          if (keyResult.issues) {\n            pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyResult.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = keyResult.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          const valueResult = this.value._parse(inputValue, config);\n          if (valueResult.issues) {\n            pathItem = pathItem ?? {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueResult.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = valueResult.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!keyResult.typed || !valueResult.typed) {\n            typed = false;\n          }\n          output.set(keyResult.output, valueResult.output);\n        }\n        if (typed) {\n          return pipeResult(this, output, config, issues);\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, map, input, config);\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, arg3, arg4) {\n  const [message, pipe] = defaultArgs(arg3, arg4);\n  return {\n    type: \"map\",\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input instanceof Map) {\n        let typed = true;\n        let issues;\n        const output = /* @__PURE__ */ new Map();\n        await Promise.all(\n          Array.from(input.entries()).map(async ([inputKey, inputValue]) => {\n            let pathItem;\n            const [keyResult, valueResult] = await Promise.all(\n              [\n                { schema: this.key, value: inputKey, origin: \"key\" },\n                { schema: this.value, value: inputValue, origin: \"value\" }\n              ].map(async ({ schema, value: value3, origin }) => {\n                if (!(config?.abortEarly && issues)) {\n                  const result = await schema._parse(value3, config);\n                  if (!(config?.abortEarly && issues)) {\n                    if (result.issues) {\n                      pathItem = pathItem ?? {\n                        type: \"map\",\n                        origin,\n                        input,\n                        key: inputKey,\n                        value: inputValue\n                      };\n                      for (const issue of result.issues) {\n                        if (issue.path) {\n                          issue.path.unshift(pathItem);\n                        } else {\n                          issue.path = [pathItem];\n                        }\n                        issues?.push(issue);\n                      }\n                      if (!issues) {\n                        issues = result.issues;\n                      }\n                      if (config?.abortEarly) {\n                        throw null;\n                      }\n                    }\n                    return result;\n                  }\n                }\n              })\n            ).catch(() => []);\n            if (!keyResult?.typed || !valueResult?.typed) {\n              typed = false;\n            }\n            if (keyResult && valueResult) {\n              output.set(keyResult.output, valueResult.output);\n            }\n          })\n        );\n        if (typed) {\n          return pipeResultAsync(this, output, config, issues);\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, mapAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message) {\n  return {\n    type: \"nan\",\n    expects: \"NaN\",\n    async: false,\n    message,\n    _parse(input, config) {\n      if (Number.isNaN(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, nan, input, config);\n    }\n  };\n}\n\n// src/schemas/nan/nanAsync.ts\nfunction nanAsync(message) {\n  return {\n    type: \"nan\",\n    expects: \"NaN\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      if (Number.isNaN(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, nanAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message) {\n  return {\n    type: \"never\",\n    expects: \"never\",\n    async: false,\n    message,\n    _parse(input, config) {\n      return schemaIssue(this, never, input, config);\n    }\n  };\n}\n\n// src/schemas/never/neverAsync.ts\nfunction neverAsync(message) {\n  return {\n    type: \"never\",\n    expects: \"never\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      return schemaIssue(this, neverAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message) {\n  return {\n    type: \"non_nullable\",\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, config) {\n      if (input === null) {\n        return schemaIssue(this, nonNullable, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    type: \"non_nullable\",\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, config) {\n      if (input === null) {\n        return schemaIssue(this, nonNullableAsync, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message) {\n  return {\n    type: \"non_nullish\",\n    expects: \"!null & !undefined\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, config) {\n      if (input === null || input === void 0) {\n        return schemaIssue(this, nonNullish, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    type: \"non_nullish\",\n    expects: \"!null & !undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, config) {\n      if (input === null || input === void 0) {\n        return schemaIssue(this, nonNullishAsync, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message) {\n  return {\n    type: \"non_optional\",\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    _parse(input, config) {\n      if (input === void 0) {\n        return schemaIssue(this, nonOptional, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    type: \"non_optional\",\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _parse(input, config) {\n      if (input === void 0) {\n        return schemaIssue(this, nonOptionalAsync, input, config);\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, default_) {\n  return {\n    type: \"nullable\",\n    expects: `${wrapped.expects} | null`,\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, config) {\n      if (input === null) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, default_) {\n  return {\n    type: \"nullable\",\n    expects: `${wrapped.expects} | null`,\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, config) {\n      if (input === null) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, default_) {\n  return {\n    type: \"nullish\",\n    expects: `${wrapped.expects} | null | undefined`,\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, config) {\n      if (input === null || input === void 0) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, default_) {\n  return {\n    type: \"nullish\",\n    expects: `${wrapped.expects} | null | undefined`,\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, config) {\n      if (input === null || input === void 0) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message) {\n  return {\n    type: \"null\",\n    expects: \"null\",\n    async: false,\n    message,\n    _parse(input, config) {\n      if (input === null) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, null_, input, config);\n    }\n  };\n}\nvar nullType = null_;\n\n// src/schemas/null/nullAsync.ts\nfunction nullAsync(message) {\n  return {\n    type: \"null\",\n    expects: \"null\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      if (input === null) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, nullAsync, input, config);\n    }\n  };\n}\nvar nullTypeAsync = nullAsync;\n\n// src/schemas/number/number.ts\nfunction number(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"number\",\n    expects: \"number\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (typeof input === \"number\" && !isNaN(input)) {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, number, input, config);\n    }\n  };\n}\n\n// src/schemas/number/numberAsync.ts\nfunction numberAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"number\",\n    expects: \"number\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (typeof input === \"number\" && !isNaN(input)) {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, numberAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    type: \"object\",\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        cachedEntries = cachedEntries ?? Object.entries(this.entries);\n        let typed = true;\n        let issues;\n        const output = {};\n        for (const [key, schema] of cachedEntries) {\n          const value2 = input[key];\n          const result = schema._parse(value2, config);\n          if (result.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!result.typed) {\n            typed = false;\n          }\n          if (result.output !== void 0 || key in input) {\n            output[key] = result.output;\n          }\n        }\n        if (this.rest && !(config?.abortEarly && issues)) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              const result = this.rest._parse(value2, config);\n              if (result.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of result.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  issues?.push(issue);\n                }\n                if (!issues) {\n                  issues = result.issues;\n                }\n                if (config?.abortEarly) {\n                  typed = false;\n                  break;\n                }\n              }\n              if (!result.typed) {\n                typed = false;\n              }\n              output[key] = result.output;\n            }\n          }\n        }\n        if (typed) {\n          return pipeResult(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, object, input, config);\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  let cachedEntries;\n  return {\n    type: \"object\",\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        cachedEntries = cachedEntries ?? Object.entries(this.entries);\n        let typed = true;\n        let issues;\n        const output = {};\n        await Promise.all([\n          Promise.all(\n            cachedEntries.map(async ([key, schema]) => {\n              if (!(config?.abortEarly && issues)) {\n                const value2 = input[key];\n                const result = await schema._parse(value2, config);\n                if (!(config?.abortEarly && issues)) {\n                  if (result.issues) {\n                    const pathItem = {\n                      type: \"object\",\n                      origin: \"value\",\n                      input,\n                      key,\n                      value: value2\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (config?.abortEarly) {\n                      typed = false;\n                      throw null;\n                    }\n                  }\n                  if (!result.typed) {\n                    typed = false;\n                  }\n                  if (result.output !== void 0 || key in input) {\n                    output[key] = result.output;\n                  }\n                }\n              }\n            })\n          ),\n          this.rest && Promise.all(\n            Object.entries(input).map(async ([key, value2]) => {\n              if (!(config?.abortEarly && issues)) {\n                if (!(key in this.entries)) {\n                  const result = await this.rest._parse(value2, config);\n                  if (!(config?.abortEarly && issues)) {\n                    if (result.issues) {\n                      const pathItem = {\n                        type: \"object\",\n                        origin: \"value\",\n                        input,\n                        key,\n                        value: value2\n                      };\n                      for (const issue of result.issues) {\n                        if (issue.path) {\n                          issue.path.unshift(pathItem);\n                        } else {\n                          issue.path = [pathItem];\n                        }\n                        issues?.push(issue);\n                      }\n                      if (!issues) {\n                        issues = result.issues;\n                      }\n                      if (config?.abortEarly) {\n                        typed = false;\n                        throw null;\n                      }\n                    }\n                    if (!result.typed) {\n                      typed = false;\n                    }\n                    output[key] = result.output;\n                  }\n                }\n              }\n            })\n          )\n        ]).catch(() => null);\n        if (typed) {\n          return pipeResultAsync(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, objectAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, default_) {\n  return {\n    type: \"optional\",\n    expects: `${wrapped.expects} | undefined`,\n    async: false,\n    wrapped,\n    default: default_,\n    _parse(input, config) {\n      if (input === void 0) {\n        const override = getDefault(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, default_) {\n  return {\n    type: \"optional\",\n    expects: `${wrapped.expects} | undefined`,\n    async: true,\n    wrapped,\n    default: default_,\n    async _parse(input, config) {\n      if (input === void 0) {\n        const override = await getDefaultAsync(this);\n        if (override === void 0) {\n          return schemaResult(true, input);\n        }\n        input = override;\n      }\n      return this.wrapped._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message) {\n  return {\n    type: \"picklist\",\n    expects: options.map(stringify).join(\" | \"),\n    async: false,\n    options,\n    message,\n    _parse(input, config) {\n      if (this.options.includes(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, picklist, input, config);\n    }\n  };\n}\nvar enumType = picklist;\n\n// src/schemas/picklist/picklistAsync.ts\nfunction picklistAsync(options, message) {\n  return {\n    type: \"picklist\",\n    expects: options.map(stringify).join(\" | \"),\n    async: true,\n    options,\n    message,\n    async _parse(input, config) {\n      if (this.options.includes(input)) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, picklistAsync, input, config);\n    }\n  };\n}\nvar enumTypeAsync = picklistAsync;\n\n// src/schemas/string/string.ts\nfunction string(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"string\",\n    expects: \"string\",\n    async: false,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (typeof input === \"string\") {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, string, input, config);\n    }\n  };\n}\n\n// src/schemas/string/stringAsync.ts\nfunction stringAsync(arg1, arg2) {\n  const [message, pipe] = defaultArgs(arg1, arg2);\n  return {\n    type: \"string\",\n    expects: \"string\",\n    async: true,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (typeof input === \"string\") {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, stringAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/record/utils/recordArgs/recordArgs.ts\nfunction recordArgs(arg1, arg2, arg3, arg4) {\n  if (typeof arg2 === \"object\" && !Array.isArray(arg2)) {\n    const [message2, pipe2] = defaultArgs(arg3, arg4);\n    return [arg1, arg2, message2, pipe2];\n  }\n  const [message, pipe] = defaultArgs(\n    arg2,\n    arg3\n  );\n  return [string(), arg1, message, pipe];\n}\n\n// src/schemas/record/values.ts\nvar BLOCKED_KEYS = [\"__proto__\", \"prototype\", \"constructor\"];\n\n// src/schemas/record/record.ts\nfunction record(arg1, arg2, arg3, arg4) {\n  const [key, value2, message, pipe] = recordArgs(arg1, arg2, arg3, arg4);\n  return {\n    type: \"record\",\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        let typed = true;\n        let issues;\n        const output = {};\n        for (const [inputKey, inputValue] of Object.entries(input)) {\n          if (!BLOCKED_KEYS.includes(inputKey)) {\n            let pathItem;\n            const keyResult = this.key._parse(inputKey, config);\n            if (keyResult.issues) {\n              pathItem = {\n                type: \"record\",\n                origin: \"key\",\n                input,\n                key: inputKey,\n                value: inputValue\n              };\n              for (const issue of keyResult.issues) {\n                issue.path = [pathItem];\n                issues?.push(issue);\n              }\n              if (!issues) {\n                issues = keyResult.issues;\n              }\n              if (config?.abortEarly) {\n                typed = false;\n                break;\n              }\n            }\n            const valueResult = this.value._parse(inputValue, config);\n            if (valueResult.issues) {\n              pathItem = pathItem ?? {\n                type: \"record\",\n                origin: \"value\",\n                input,\n                key: inputKey,\n                value: inputValue\n              };\n              for (const issue of valueResult.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                issues?.push(issue);\n              }\n              if (!issues) {\n                issues = valueResult.issues;\n              }\n              if (config?.abortEarly) {\n                typed = false;\n                break;\n              }\n            }\n            if (!keyResult.typed || !valueResult.typed) {\n              typed = false;\n            }\n            if (keyResult.typed) {\n              output[keyResult.output] = valueResult.output;\n            }\n          }\n        }\n        if (typed) {\n          return pipeResult(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, record, input, config);\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(arg1, arg2, arg3, arg4) {\n  const [key, value2, message, pipe] = recordArgs(arg1, arg2, arg3, arg4);\n  return {\n    type: \"record\",\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        let typed = true;\n        let issues;\n        const output = {};\n        await Promise.all(\n          // Note: `Object.entries(...)` converts each key to a string\n          Object.entries(input).map(async ([inputKey, inputValue]) => {\n            if (!BLOCKED_KEYS.includes(inputKey)) {\n              let pathItem;\n              const [keyResult, valueResult] = await Promise.all(\n                [\n                  { schema: this.key, value: inputKey, origin: \"key\" },\n                  { schema: this.value, value: inputValue, origin: \"value\" }\n                ].map(async ({ schema, value: value3, origin }) => {\n                  if (!(config?.abortEarly && issues)) {\n                    const result = await schema._parse(value3, config);\n                    if (!(config?.abortEarly && issues)) {\n                      if (result.issues) {\n                        pathItem = pathItem ?? {\n                          type: \"record\",\n                          origin,\n                          input,\n                          key: inputKey,\n                          value: inputValue\n                        };\n                        for (const issue of result.issues) {\n                          if (issue.path) {\n                            issue.path.unshift(pathItem);\n                          } else {\n                            issue.path = [pathItem];\n                          }\n                          issues?.push(issue);\n                        }\n                        if (!issues) {\n                          issues = result.issues;\n                        }\n                        if (config?.abortEarly) {\n                          throw null;\n                        }\n                      }\n                      return result;\n                    }\n                  }\n                })\n              ).catch(() => []);\n              if (!keyResult?.typed || !valueResult?.typed) {\n                typed = false;\n              }\n              if (keyResult?.typed && valueResult) {\n                output[keyResult.output] = valueResult.output;\n              }\n            }\n          })\n        );\n        if (typed) {\n          return pipeResultAsync(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, recordAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/recursive/recursive.ts\nfunction recursive(getter) {\n  return {\n    type: \"recursive\",\n    expects: \"unknown\",\n    async: false,\n    getter,\n    _parse(input, config) {\n      return this.getter()._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/recursive/recursiveAsync.ts\nfunction recursiveAsync(getter) {\n  return {\n    type: \"recursive\",\n    expects: \"unknown\",\n    async: true,\n    getter,\n    async _parse(input, config) {\n      return this.getter()._parse(input, config);\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"set\",\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input instanceof Set) {\n        let key = 0;\n        let typed = true;\n        let issues;\n        const output = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const result = this.value._parse(inputValue, config);\n          if (result.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key,\n              value: inputValue\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!result.typed) {\n            typed = false;\n          }\n          output.add(result.output);\n          key++;\n        }\n        if (typed) {\n          return pipeResult(this, output, config, issues);\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, set, input, config);\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"set\",\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input instanceof Set) {\n        let typed = true;\n        let issues;\n        const output = /* @__PURE__ */ new Set();\n        await Promise.all(\n          Array.from(input.values()).map(async (inputValue, key) => {\n            if (!(config?.abortEarly && issues)) {\n              const result = await this.value._parse(inputValue, config);\n              if (!(config?.abortEarly && issues)) {\n                if (result.issues) {\n                  const pathItem = {\n                    type: \"set\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: inputValue\n                  };\n                  for (const issue of result.issues) {\n                    if (issue.path) {\n                      issue.path.unshift(pathItem);\n                    } else {\n                      issue.path = [pathItem];\n                    }\n                    issues?.push(issue);\n                  }\n                  if (!issues) {\n                    issues = result.issues;\n                  }\n                  if (config?.abortEarly) {\n                    typed = false;\n                    throw null;\n                  }\n                }\n                if (!result.typed) {\n                  typed = false;\n                }\n                output.add(result.output);\n              }\n            }\n          })\n        ).catch(() => null);\n        if (typed) {\n          return pipeResultAsync(this, output, config, issues);\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, setAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/special/special.ts\nfunction special(check, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"special\",\n    expects: \"unknown\",\n    async: false,\n    check,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (this.check(input)) {\n        return pipeResult(this, input, config);\n      }\n      return schemaIssue(this, special, input, config);\n    }\n  };\n}\n\n// src/schemas/special/specialAsync.ts\nfunction specialAsync(check, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"special\",\n    expects: \"unknown\",\n    async: true,\n    check,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (await this.check(input)) {\n        return pipeResultAsync(this, input, config);\n      }\n      return schemaIssue(this, specialAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message) {\n  return {\n    type: \"symbol\",\n    expects: \"symbol\",\n    async: false,\n    message,\n    _parse(input, config) {\n      if (typeof input === \"symbol\") {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, symbol, input, config);\n    }\n  };\n}\n\n// src/schemas/symbol/symbolAsync.ts\nfunction symbolAsync(message) {\n  return {\n    type: \"symbol\",\n    expects: \"symbol\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      if (typeof input === \"symbol\") {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, symbolAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    type: \"tuple\",\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (Array.isArray(input)) {\n        let typed = true;\n        let issues;\n        const output = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const result = this.items[key]._parse(value2, config);\n          if (result.issues) {\n            const pathItem = {\n              type: \"tuple\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of result.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              issues?.push(issue);\n            }\n            if (!issues) {\n              issues = result.issues;\n            }\n            if (config?.abortEarly) {\n              typed = false;\n              break;\n            }\n          }\n          if (!result.typed) {\n            typed = false;\n          }\n          output[key] = result.output;\n        }\n        if (this.rest && !(config?.abortEarly && issues)) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const result = this.rest._parse(value2, config);\n            if (result.issues) {\n              const pathItem = {\n                type: \"tuple\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of result.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                issues?.push(issue);\n              }\n              if (!issues) {\n                issues = result.issues;\n              }\n              if (config?.abortEarly) {\n                typed = false;\n                break;\n              }\n            }\n            if (!result.typed) {\n              typed = false;\n            }\n            output[key] = result.output;\n          }\n        }\n        if (typed) {\n          return pipeResult(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, tuple, input, config);\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return {\n    type: \"tuple\",\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (Array.isArray(input)) {\n        let typed = true;\n        let issues;\n        const output = [];\n        await Promise.all([\n          // Parse schema of each tuple item\n          Promise.all(\n            this.items.map(async (schema, key) => {\n              if (!(config?.abortEarly && issues)) {\n                const value2 = input[key];\n                const result = await schema._parse(value2, config);\n                if (!(config?.abortEarly && issues)) {\n                  if (result.issues) {\n                    const pathItem = {\n                      type: \"tuple\",\n                      origin: \"value\",\n                      input,\n                      key,\n                      value: value2\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (config?.abortEarly) {\n                      typed = false;\n                      throw null;\n                    }\n                  }\n                  if (!result.typed) {\n                    typed = false;\n                  }\n                  output[key] = result.output;\n                }\n              }\n            })\n          ),\n          // If necessary parse schema of each rest item\n          this.rest && Promise.all(\n            input.slice(this.items.length).map(async (value2, index) => {\n              if (!(config?.abortEarly && issues)) {\n                const key = this.items.length + index;\n                const result = await this.rest._parse(value2, config);\n                if (!(config?.abortEarly && issues)) {\n                  if (result.issues) {\n                    const pathItem = {\n                      type: \"tuple\",\n                      origin: \"value\",\n                      input,\n                      key,\n                      value: value2\n                    };\n                    for (const issue of result.issues) {\n                      if (issue.path) {\n                        issue.path.unshift(pathItem);\n                      } else {\n                        issue.path = [pathItem];\n                      }\n                      issues?.push(issue);\n                    }\n                    if (!issues) {\n                      issues = result.issues;\n                    }\n                    if (config?.abortEarly) {\n                      typed = false;\n                      throw null;\n                    }\n                  }\n                  if (!result.typed) {\n                    typed = false;\n                  }\n                  output[key] = result.output;\n                }\n              }\n            })\n          )\n        ]).catch(() => null);\n        if (typed) {\n          return pipeResultAsync(\n            this,\n            output,\n            config,\n            issues\n          );\n        }\n        return schemaResult(false, output, issues);\n      }\n      return schemaIssue(this, tupleAsync, input, config);\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message) {\n  return {\n    type: \"undefined\",\n    expects: \"undefined\",\n    async: false,\n    message,\n    _parse(input, config) {\n      if (input === void 0) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, undefined_, input, config);\n    }\n  };\n}\nvar undefinedType = undefined_;\n\n// src/schemas/undefined/undefinedAsync.ts\nfunction undefinedAsync(message) {\n  return {\n    type: \"undefined\",\n    expects: \"undefined\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      if (input === void 0) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, undefinedAsync, input, config);\n    }\n  };\n}\nvar undefinedTypeAsync = undefinedAsync;\n\n// src/schemas/union/utils/subissues/subissues.ts\nfunction subissues(results) {\n  let issues;\n  if (results) {\n    for (const result of results) {\n      if (issues) {\n        for (const issue of result.issues) {\n          issues.push(issue);\n        }\n      } else {\n        issues = result.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\nfunction union(options, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"union\",\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \"),\n    async: false,\n    options,\n    message,\n    pipe,\n    _parse(input, config) {\n      let validResult;\n      let untypedResults;\n      let typedResults;\n      for (const schema of this.options) {\n        const result = schema._parse(input, config);\n        if (result.typed) {\n          if (!result.issues) {\n            validResult = result;\n            break;\n          } else {\n            typedResults ? typedResults.push(result) : typedResults = [result];\n          }\n        } else {\n          untypedResults ? untypedResults.push(result) : untypedResults = [result];\n        }\n      }\n      if (validResult) {\n        return pipeResult(this, validResult.output, config);\n      }\n      if (typedResults?.length) {\n        const firstResult = typedResults[0];\n        return pipeResult(\n          this,\n          firstResult.output,\n          config,\n          // Hint: If there is more than one typed result, we use a general\n          // union issue with subissues because the issues could contradict\n          // each other.\n          typedResults.length === 1 ? firstResult.issues : schemaIssue(this, union, input, config, {\n            reason: \"union\",\n            issues: subissues(typedResults)\n          }).issues\n        );\n      }\n      if (untypedResults?.length === 1) {\n        return untypedResults[0];\n      }\n      return schemaIssue(this, union, input, config, {\n        issues: subissues(untypedResults)\n      });\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, arg2, arg3) {\n  const [message, pipe] = defaultArgs(arg2, arg3);\n  return {\n    type: \"union\",\n    expects: [...new Set(options.map((option) => option.expects))].join(\" | \"),\n    async: true,\n    options,\n    message,\n    pipe,\n    async _parse(input, config) {\n      let validResult;\n      let untypedResults;\n      let typedResults;\n      for (const schema of this.options) {\n        const result = await schema._parse(input, config);\n        if (result.typed) {\n          if (!result.issues) {\n            validResult = result;\n            break;\n          } else {\n            typedResults ? typedResults.push(result) : typedResults = [result];\n          }\n        } else {\n          untypedResults ? untypedResults.push(result) : untypedResults = [result];\n        }\n      }\n      if (validResult) {\n        return pipeResultAsync(this, validResult.output, config);\n      }\n      if (typedResults?.length) {\n        const firstResult = typedResults[0];\n        return pipeResultAsync(\n          this,\n          firstResult.output,\n          config,\n          // Hint: If there is more than one typed result, we use a general\n          // union issue with subissues because the issues could contradict\n          // each other.\n          typedResults.length === 1 ? firstResult.issues : schemaIssue(this, unionAsync, input, config, {\n            reason: \"union\",\n            issues: subissues(typedResults)\n          }).issues\n        );\n      }\n      if (untypedResults?.length === 1) {\n        return untypedResults[0];\n      }\n      return schemaIssue(this, unionAsync, input, config, {\n        issues: subissues(untypedResults)\n      });\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown(pipe) {\n  return {\n    type: \"unknown\",\n    expects: \"unknown\",\n    async: false,\n    pipe,\n    _parse(input, config) {\n      return pipeResult(this, input, config);\n    }\n  };\n}\n\n// src/schemas/unknown/unknownAsync.ts\nfunction unknownAsync(pipe) {\n  return {\n    type: \"unknown\",\n    expects: \"unknown\",\n    async: true,\n    pipe,\n    async _parse(input, config) {\n      return pipeResultAsync(this, input, config);\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, arg3, arg4) {\n  const [message, pipe] = defaultArgs(arg3, arg4);\n  let cachedExpectedKey;\n  return {\n    type: \"variant\",\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    pipe,\n    _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        if (this.key in input || !cachedExpectedKey) {\n          let expectedKey;\n          let variantResult;\n          const parseOptions = (options2) => {\n            for (const schema of options2) {\n              if (schema.type === \"object\") {\n                const keySchema = schema.entries[this.key];\n                const keyResult = keySchema._parse(\n                  input[this.key],\n                  config\n                );\n                if (!cachedExpectedKey) {\n                  expectedKey ? expectedKey.push(keySchema.expects) : expectedKey = [keySchema.expects];\n                }\n                if (!keyResult.issues) {\n                  const dataResult = schema._parse(input, config);\n                  if (!dataResult.issues) {\n                    variantResult = dataResult;\n                    break;\n                  }\n                  if (!variantResult || !variantResult.typed && dataResult.typed) {\n                    variantResult = dataResult;\n                  }\n                }\n              } else if (schema.type === \"variant\") {\n                parseOptions(schema.options);\n                if (variantResult && !variantResult.issues) {\n                  break;\n                }\n              }\n            }\n          };\n          parseOptions(this.options);\n          cachedExpectedKey = cachedExpectedKey || [...new Set(expectedKey)].join(\" | \");\n          if (variantResult) {\n            if (variantResult.typed) {\n              return pipeResult(\n                this,\n                variantResult.output,\n                config,\n                variantResult.issues\n              );\n            }\n            return variantResult;\n          }\n        }\n        const value2 = input[this.key];\n        return schemaIssue(this, variant, value2, config, {\n          expected: cachedExpectedKey,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: value2\n            }\n          ]\n        });\n      }\n      return schemaIssue(this, variant, input, config);\n    }\n  };\n}\nvar discriminatedUnion = variant;\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, arg3, arg4) {\n  const [message, pipe] = defaultArgs(arg3, arg4);\n  let cachedExpectedKey;\n  return {\n    type: \"variant\",\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    pipe,\n    async _parse(input, config) {\n      if (input && typeof input === \"object\") {\n        if (this.key in input || !cachedExpectedKey) {\n          let expectedKey;\n          let variantResult;\n          const parseOptions = async (options2) => {\n            for (const schema of options2) {\n              if (schema.type === \"object\") {\n                const keySchema = schema.entries[this.key];\n                const keyResult = await keySchema._parse(\n                  input[this.key],\n                  config\n                );\n                if (!cachedExpectedKey) {\n                  expectedKey ? expectedKey.push(keySchema.expects) : expectedKey = [keySchema.expects];\n                }\n                if (!keyResult.issues) {\n                  const dataResult = await schema._parse(input, config);\n                  if (!dataResult.issues) {\n                    variantResult = dataResult;\n                    break;\n                  }\n                  if (!variantResult || !variantResult.typed && dataResult.typed) {\n                    variantResult = dataResult;\n                  }\n                }\n              } else if (schema.type === \"variant\") {\n                await parseOptions(schema.options);\n                if (variantResult && !variantResult.issues) {\n                  break;\n                }\n              }\n            }\n          };\n          await parseOptions(this.options);\n          cachedExpectedKey = cachedExpectedKey || [...new Set(expectedKey)].join(\" | \");\n          if (variantResult) {\n            if (variantResult.typed) {\n              return pipeResultAsync(\n                this,\n                variantResult.output,\n                config,\n                variantResult.issues\n              );\n            }\n            return variantResult;\n          }\n        }\n        const value2 = input[this.key];\n        return schemaIssue(this, variantAsync, value2, config, {\n          expected: cachedExpectedKey,\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: this.key,\n              value: value2\n            }\n          ]\n        });\n      }\n      return schemaIssue(this, variantAsync, input, config);\n    }\n  };\n}\nvar discriminatedUnionAsync = variantAsync;\n\n// src/schemas/void/void.ts\nfunction void_(message) {\n  return {\n    type: \"void\",\n    expects: \"void\",\n    async: false,\n    message,\n    _parse(input, config) {\n      if (input === void 0) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, void_, input, config);\n    }\n  };\n}\nvar voidType = void_;\n\n// src/schemas/void/voidAsync.ts\nfunction voidAsync(message) {\n  return {\n    type: \"void\",\n    expects: \"void\",\n    async: true,\n    message,\n    async _parse(input, config) {\n      if (input === void 0) {\n        return schemaResult(true, input);\n      }\n      return schemaIssue(this, voidAsync, input, config);\n    }\n  };\n}\nvar voidTypeAsync = voidAsync;\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema) {\n  return picklist(\n    Object.keys(schema.entries)\n  );\n}\n\n// src/methods/merge/merge.ts\nfunction merge(schemas, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/merge/mergeAsync.ts\nfunction mergeAsync(schemas, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    schemas.reduce(\n      (entries, schema) => ({ ...entries, ...schema.entries }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/omit/omitAsync.ts\nfunction omitAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? entries : { ...entries, [key]: schema2 },\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config) {\n  const result = schema._parse(input, getGlobalConfig(config));\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config) {\n  const result = await schema._parse(input, getGlobalConfig(config));\n  if (result.issues) {\n    throw new ValiError(result.issues);\n  }\n  return result.output;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: optionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/passthrough/passthrough.ts\nfunction passthrough(schema) {\n  return {\n    ...schema,\n    _parse(input, config) {\n      const result = schema._parse(input, config);\n      if (result.typed) {\n        result.output = { ...input, ...result.output };\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/passthrough/passthroughAsync.ts\nfunction passthroughAsync(schema) {\n  return {\n    ...schema,\n    async _parse(input, config) {\n      const result = await schema._parse(input, config);\n      if (result.typed) {\n        result.output = { ...input, ...result.output };\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/pick/pickAsync.ts\nfunction pickAsync(schema, keys, arg3, arg4, arg5) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg3, arg4, arg5);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => keys.includes(key) ? { ...entries, [key]: schema2 } : entries,\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return object(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptional(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3, arg4) {\n  const [rest, message, pipe] = restAndDefaultArgs(arg2, arg3, arg4);\n  return objectAsync(\n    Object.entries(schema.entries).reduce(\n      (entries, [key, schema2]) => ({\n        ...entries,\n        [key]: nonOptionalAsync(schema2)\n      }),\n      {}\n    ),\n    rest,\n    message,\n    pipe\n  );\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, config) {\n  const result = schema._parse(input, getGlobalConfig(config));\n  return {\n    typed: result.typed,\n    success: !result.issues,\n    data: result.output,\n    output: result.output,\n    error: result.issues && new ValiError(result.issues),\n    issues: result.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, config) {\n  const result = await schema._parse(input, getGlobalConfig(config));\n  return {\n    typed: result.typed,\n    success: !result.issues,\n    data: result.output,\n    output: result.output,\n    error: result.issues && new ValiError(result.issues),\n    issues: result.issues\n  };\n}\n\n// src/methods/strict/strict.ts\nfunction strict(schema) {\n  return {\n    ...schema,\n    _parse(input, config) {\n      const result = schema._parse(input, config);\n      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? schemaIssue(this, object, input, config) : result;\n    }\n  };\n}\n\n// src/methods/strict/strictAsync.ts\nfunction strictAsync(schema) {\n  return {\n    ...schema,\n    async _parse(input, config) {\n      const result = await schema._parse(input, config);\n      return !result.issues && Object.keys(input).some((key) => !(key in schema.entries)) ? schemaIssue(this, objectAsync, input, config) : result;\n    }\n  };\n}\n\n// src/methods/strip/strip.ts\nfunction strip(schema) {\n  let cachedKeys;\n  return {\n    ...schema,\n    _parse(input, config) {\n      const result = schema._parse(input, config);\n      if (result.typed) {\n        cachedKeys = cachedKeys ?? Object.keys(schema.entries);\n        const output = {};\n        for (const key of cachedKeys) {\n          output[key] = result.output[key];\n        }\n        result.output = output;\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/strip/stripAsync.ts\nfunction stripAsync(schema) {\n  let cachedKeys;\n  return {\n    ...schema,\n    async _parse(input, config) {\n      const result = await schema._parse(input, config);\n      if (result.typed) {\n        cachedKeys = cachedKeys ?? Object.keys(schema.entries);\n        const output = {};\n        for (const key of cachedKeys) {\n          output[key] = result.output[key];\n        }\n        result.output = output;\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/transform/transform.ts\nfunction transform(schema, action, arg1) {\n  return {\n    ...schema,\n    _parse(input, config) {\n      const result = schema._parse(input, config);\n      if (result.typed) {\n        result.output = action(result.output, { issues: result.issues });\n        if (result.issues || !arg1) {\n          return result;\n        }\n        if (Array.isArray(arg1)) {\n          return pipeResult(\n            { type: typeof result.output, pipe: arg1 },\n            result.output,\n            config\n          );\n        }\n        return arg1._parse(result.output, config);\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/transform/transformAsync.ts\nfunction transformAsync(schema, action, arg1) {\n  return {\n    ...schema,\n    async: true,\n    async _parse(input, config) {\n      const result = await schema._parse(input, config);\n      if (result.typed) {\n        result.output = await action(result.output, { issues: result.issues });\n        if (result.issues || !arg1) {\n          return result;\n        }\n        if (Array.isArray(arg1)) {\n          return pipeResultAsync(\n            { type: typeof result.output, pipe: arg1 },\n            result.output,\n            config\n          );\n        }\n        return arg1._parse(result.output, config);\n      }\n      return result;\n    }\n  };\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\n\n// src/methods/withDefault/withDefault.ts\nfunction withDefault(schema, value2) {\n  return {\n    ...schema,\n    _parse(input, config) {\n      return schema._parse(\n        input === void 0 ? typeof value2 === \"function\" ? value2() : value2 : input,\n        config\n      );\n    }\n  };\n}\nvar useDefault = withDefault;\n\n// src/regex.ts\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar HEXADECIMAL_REGEX = /^(0h|0x)?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#([\\da-f]{3}|[\\da-f]{4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{2}(?:[ /|-]?\\d{6}){2}[ /|-]?\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?Z$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/transformations/toCustom/toCustom.ts\nfunction toCustom(action) {\n  return {\n    type: \"to_custom\",\n    async: false,\n    _parse(input) {\n      return actionOutput(action(input));\n    }\n  };\n}\n\n// src/transformations/toCustom/toCustomAsync.ts\nfunction toCustomAsync(action) {\n  return {\n    type: \"to_custom\",\n    async: true,\n    async _parse(input) {\n      return actionOutput(await action(input));\n    }\n  };\n}\n\n// src/transformations/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    type: \"to_lower_case\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.toLocaleLowerCase());\n    }\n  };\n}\n\n// src/transformations/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    type: \"to_max_value\",\n    async: false,\n    requirement,\n    _parse(input) {\n      return actionOutput(input > this.requirement ? this.requirement : input);\n    }\n  };\n}\n\n// src/transformations/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    type: \"to_min_value\",\n    async: false,\n    requirement,\n    _parse(input) {\n      return actionOutput(input < this.requirement ? this.requirement : input);\n    }\n  };\n}\n\n// src/transformations/toTrimmed/toTrimmed.ts\nfunction toTrimmed() {\n  return {\n    type: \"to_trimmed\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.trim());\n    }\n  };\n}\n\n// src/transformations/toTrimmedEnd/toTrimmedEnd.ts\nfunction toTrimmedEnd() {\n  return {\n    type: \"to_trimmed_end\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.trimEnd());\n    }\n  };\n}\n\n// src/transformations/toTrimmedStart/toTrimmedStart.ts\nfunction toTrimmedStart() {\n  return {\n    type: \"to_trimmed_start\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.trimStart());\n    }\n  };\n}\n\n// src/transformations/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    type: \"to_upper_case\",\n    async: false,\n    _parse(input) {\n      return actionOutput(input.toUpperCase());\n    }\n  };\n}\n\n// src/validations/bic/bic.ts\nfunction bic(message) {\n  return {\n    type: \"bic\",\n    expects: null,\n    async: false,\n    message,\n    requirement: BIC_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, bic, input, \"BIC\");\n    }\n  };\n}\n\n// src/validations/bytes/bytes.ts\nfunction bytes(requirement, message) {\n  return {\n    type: \"bytes\",\n    expects: `${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      const length2 = new TextEncoder().encode(input).length;\n      if (length2 === this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, bytes, input, \"bytes\", `${length2}`);\n    }\n  };\n}\n\n// src/validations/creditCard/creditCard.ts\nvar SANITIZE_REGEX = /[- ]+/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  /^5[1-5]\\d{2}|(222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(6[27]\\d{14}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message) {\n  return {\n    type: \"credit_card\",\n    expects: null,\n    async: false,\n    message,\n    requirement: (input) => {\n      const sanitized = input.replace(SANITIZE_REGEX, \"\");\n      return PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && isLuhnAlgo(sanitized);\n    },\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, creditCard, input, \"credit card\");\n    }\n  };\n}\n\n// src/validations/cuid2/cuid2.ts\nfunction cuid2(message) {\n  return {\n    type: \"cuid2\",\n    expects: null,\n    async: false,\n    message,\n    requirement: CUID2_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, cuid2, input, \"Cuid2\");\n    }\n  };\n}\n\n// src/validations/custom/custom.ts\nfunction custom(requirement, message) {\n  return {\n    type: \"custom\",\n    expects: null,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, custom, input, \"input\");\n    }\n  };\n}\n\n// src/validations/custom/customAsync.ts\nfunction customAsync(requirement, message) {\n  return {\n    type: \"custom\",\n    expects: null,\n    async: true,\n    message,\n    requirement,\n    async _parse(input) {\n      if (await this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, customAsync, input, \"input\");\n    }\n  };\n}\n\n// src/validations/decimal/decimal.ts\nfunction decimal(message) {\n  return {\n    type: \"decimal\",\n    expects: null,\n    async: false,\n    message,\n    requirement: DECIMAL_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, decimal, input, \"decimal\");\n    }\n  };\n}\n\n// src/validations/email/email.ts\nfunction email(message) {\n  return {\n    type: \"email\",\n    expects: null,\n    async: false,\n    message,\n    requirement: EMAIL_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, email, input, \"email\");\n    }\n  };\n}\n\n// src/validations/emoji/emoji.ts\nfunction emoji(message) {\n  return {\n    type: \"emoji\",\n    expects: null,\n    async: false,\n    message,\n    requirement: EMOJI_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, emoji, input, \"emoji\");\n    }\n  };\n}\n\n// src/validations/endsWith/endsWith.ts\nfunction endsWith(requirement, message) {\n  return {\n    type: \"ends_with\",\n    expects: `\"${requirement}\"`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.endsWith(this.requirement)) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        endsWith,\n        input,\n        \"end\",\n        `\"${input.slice(-this.requirement.length)}\"`\n      );\n    }\n  };\n}\n\n// src/validations/equal/equal.ts\nfunction equal(requirement, message) {\n  return {\n    type: \"equal\",\n    expects: stringify(requirement),\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input === this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, equal, input, \"value\");\n    }\n  };\n}\n\n// src/validations/excludes/excludes.ts\nfunction excludes(requirement, message) {\n  const received = stringify(requirement);\n  return {\n    type: \"excludes\",\n    expects: `!${received}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (!input.includes(this.requirement)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, excludes, input, \"content\", received);\n    }\n  };\n}\n\n// src/validations/finite/finite.ts\nfunction finite(message) {\n  return {\n    type: \"finite\",\n    expects: null,\n    async: false,\n    message,\n    requirement: Number.isFinite,\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, finite, input, \"finite\");\n    }\n  };\n}\n\n// src/validations/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\nfunction hash(types, message) {\n  return {\n    type: \"hash\",\n    expects: null,\n    async: false,\n    message,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, hash, input, \"hash\");\n    }\n  };\n}\n\n// src/validations/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message) {\n  return {\n    type: \"hexadecimal\",\n    expects: null,\n    async: false,\n    message,\n    requirement: HEXADECIMAL_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, hexadecimal, input, \"hexadecimal\");\n    }\n  };\n}\n\n// src/validations/hexColor/hexColor.ts\nfunction hexColor(message) {\n  return {\n    type: \"hex_color\",\n    expects: null,\n    async: false,\n    message,\n    requirement: HEX_COLOR_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, hexColor, input, \"hex color\");\n    }\n  };\n}\n\n// src/validations/imei/imei.ts\nfunction imei(message) {\n  return {\n    type: \"imei\",\n    expects: null,\n    async: false,\n    message,\n    requirement: [IMEI_REGEX, isLuhnAlgo],\n    _parse(input) {\n      if (this.requirement[0].test(input) && this.requirement[1](input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, imei, input, \"IMEI\");\n    }\n  };\n}\n\n// src/validations/includes/includes.ts\nfunction includes(requirement, message) {\n  const expects = stringify(requirement);\n  return {\n    type: \"includes\",\n    expects,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.includes(this.requirement)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, includes, input, \"content\", `!${expects}`);\n    }\n  };\n}\n\n// src/validations/integer/integer.ts\nfunction integer(message) {\n  return {\n    type: \"integer\",\n    expects: null,\n    async: false,\n    message,\n    requirement: Number.isInteger,\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, integer, input, \"integer\");\n    }\n  };\n}\n\n// src/validations/ip/ip.ts\nfunction ip(message) {\n  return {\n    type: \"ip\",\n    expects: null,\n    async: false,\n    message,\n    // TODO: It is strange that we have an OR relationship between requirements\n    requirement: [IPV4_REGEX, IPV6_REGEX],\n    _parse(input) {\n      if (this.requirement[0].test(input) || this.requirement[1].test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, ip, input, \"IP\");\n    }\n  };\n}\n\n// src/validations/ipv4/ipv4.ts\nfunction ipv4(message) {\n  return {\n    type: \"ipv4\",\n    expects: null,\n    async: false,\n    message,\n    requirement: IPV4_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, ipv4, input, \"IPv4\");\n    }\n  };\n}\n\n// src/validations/ipv6/ipv6.ts\nfunction ipv6(message) {\n  return {\n    type: \"ipv6\",\n    expects: null,\n    async: false,\n    message,\n    requirement: IPV6_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, ipv6, input, \"IPv6\");\n    }\n  };\n}\n\n// src/validations/isoDate/isoDate.ts\nfunction isoDate(message) {\n  return {\n    type: \"iso_date\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_DATE_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoDate, input, \"date\");\n    }\n  };\n}\n\n// src/validations/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message) {\n  return {\n    type: \"iso_date_time\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_DATE_TIME_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoDateTime, input, \"date-time\");\n    }\n  };\n}\n\n// src/validations/isoTime/isoTime.ts\nfunction isoTime(message) {\n  return {\n    type: \"iso_time\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_TIME_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoTime, input, \"time\");\n    }\n  };\n}\n\n// src/validations/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message) {\n  return {\n    type: \"iso_time_second\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_TIME_SECOND_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoTimeSecond, input, \"time second\");\n    }\n  };\n}\n\n// src/validations/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message) {\n  return {\n    type: \"iso_timestamp\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_TIMESTAMP_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoTimestamp, input, \"timestamp\");\n    }\n  };\n}\n\n// src/validations/isoWeek/isoWeek.ts\nfunction isoWeek(message) {\n  return {\n    type: \"iso_week\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ISO_WEEK_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, isoWeek, input, \"week\");\n    }\n  };\n}\n\n// src/validations/length/length.ts\nfunction length(requirement, message) {\n  return {\n    type: \"length\",\n    expects: `${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.length === this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, length, input, \"length\", `${input.length}`);\n    }\n  };\n}\n\n// src/validations/mac/mac.ts\nfunction mac(message) {\n  return {\n    type: \"mac\",\n    expects: null,\n    async: false,\n    message,\n    // TODO: It is strange that we have an OR relationship between requirements\n    requirement: [MAC48_REGEX, MAC64_REGEX],\n    _parse(input) {\n      if (this.requirement[0].test(input) || this.requirement[1].test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, mac, input, \"MAC\");\n    }\n  };\n}\n\n// src/validations/mac48/mac48.ts\nfunction mac48(message) {\n  return {\n    type: \"mac48\",\n    expects: null,\n    async: false,\n    message,\n    requirement: MAC48_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, mac48, input, \"48-bit MAC\");\n    }\n  };\n}\n\n// src/validations/mac64/mac64.ts\nfunction mac64(message) {\n  return {\n    type: \"mac64\",\n    expects: null,\n    async: false,\n    message,\n    requirement: MAC64_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, mac64, input, \"64-bit MAC\");\n    }\n  };\n}\n\n// src/validations/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message) {\n  return {\n    type: \"max_bytes\",\n    expects: `<=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      const length2 = new TextEncoder().encode(input).length;\n      if (length2 <= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, maxBytes, input, \"bytes\", `${length2}`);\n    }\n  };\n}\n\n// src/validations/maxLength/maxLength.ts\nfunction maxLength(requirement, message) {\n  return {\n    type: \"max_length\",\n    expects: `<=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.length <= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, maxLength, input, \"length\", `${input.length}`);\n    }\n  };\n}\n\n// src/validations/maxSize/maxSize.ts\nfunction maxSize(requirement, message) {\n  return {\n    type: \"max_size\",\n    expects: `<=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.size <= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, maxSize, input, \"size\", `${input.size}`);\n    }\n  };\n}\n\n// src/validations/maxValue/maxValue.ts\nfunction maxValue(requirement, message) {\n  return {\n    type: \"max_value\",\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : stringify(requirement)}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input <= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        maxValue,\n        input,\n        \"value\",\n        input instanceof Date ? input.toJSON() : stringify(input)\n      );\n    }\n  };\n}\nvar maxRange = maxValue;\n\n// src/validations/minBytes/minBytes.ts\nfunction minBytes(requirement, message) {\n  return {\n    type: \"min_bytes\",\n    expects: `>=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      const length2 = new TextEncoder().encode(input).length;\n      if (length2 >= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, minBytes, input, \"bytes\", `${length2}`);\n    }\n  };\n}\n\n// src/validations/mimeType/mimeType.ts\nfunction mimeType(requirement, message) {\n  return {\n    type: \"mime_type\",\n    expects: requirement.map((option) => `\"${option}\"`).join(\" | \"),\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (this.requirement.includes(input.type)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, mimeType, input, \"MIME type\");\n    }\n  };\n}\n\n// src/validations/minLength/minLength.ts\nfunction minLength(requirement, message) {\n  return {\n    type: \"min_length\",\n    expects: `>=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.length >= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, minLength, input, \"length\", `${input.length}`);\n    }\n  };\n}\n\n// src/validations/minSize/minSize.ts\nfunction minSize(requirement, message) {\n  return {\n    type: \"min_size\",\n    expects: `>=${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.size >= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, minSize, input, \"size\", `${input.size}`);\n    }\n  };\n}\n\n// src/validations/minValue/minValue.ts\nfunction minValue(requirement, message) {\n  return {\n    type: \"min_value\",\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : stringify(requirement)}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input >= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        minValue,\n        input,\n        \"value\",\n        input instanceof Date ? input.toJSON() : stringify(input)\n      );\n    }\n  };\n}\nvar minRange = minValue;\n\n// src/validations/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message) {\n  return {\n    type: \"multiple_of\",\n    expects: `%${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input % this.requirement === 0) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, multipleOf, input, \"multiple\", `${input}`);\n    }\n  };\n}\n\n// src/validations/notBytes/notBytes.ts\nfunction notBytes(requirement, message) {\n  return {\n    type: \"not_bytes\",\n    expects: `!${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      const length2 = new TextEncoder().encode(input).length;\n      if (length2 !== this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, notBytes, input, \"bytes\", `${length2}`);\n    }\n  };\n}\n\n// src/validations/notLength/notLength.ts\nfunction notLength(requirement, message) {\n  return {\n    type: \"not_length\",\n    expects: `!${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.length !== this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, notLength, input, \"length\", `${input.length}`);\n    }\n  };\n}\n\n// src/validations/notSize/notSize.ts\nfunction notSize(requirement, message) {\n  return {\n    type: \"not_size\",\n    expects: `!${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.size !== this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, notSize, input, \"size\", `${input.size}`);\n    }\n  };\n}\n\n// src/validations/notValue/notValue.ts\nfunction notValue(requirement, message) {\n  return {\n    type: \"not_value\",\n    expects: `!${requirement instanceof Date ? requirement.toJSON() : stringify(requirement)}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input < this.requirement || input > this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        notValue,\n        input,\n        \"value\",\n        input instanceof Date ? input.toJSON() : stringify(input)\n      );\n    }\n  };\n}\n\n// src/validations/octal/octal.ts\nfunction octal(message) {\n  return {\n    type: \"octal\",\n    expects: null,\n    async: false,\n    message,\n    requirement: OCTAL_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, octal, input, \"octal\");\n    }\n  };\n}\n\n// src/validations/regex/regex.ts\nfunction regex(requirement, message) {\n  return {\n    type: \"regex\",\n    expects: `${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, regex, input, \"format\");\n    }\n  };\n}\n\n// src/validations/safeInteger/safeInteger.ts\nfunction safeInteger(message) {\n  return {\n    type: \"safe_integer\",\n    expects: null,\n    async: false,\n    message,\n    requirement: Number.isSafeInteger,\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, safeInteger, input, \"safe integer\");\n    }\n  };\n}\n\n// src/validations/size/size.ts\nfunction size(requirement, message) {\n  return {\n    type: \"size\",\n    expects: `${requirement}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.size === this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, size, input, \"size\", `${input.size}`);\n    }\n  };\n}\n\n// src/validations/startsWith/startsWith.ts\nfunction startsWith(requirement, message) {\n  return {\n    type: \"starts_with\",\n    expects: `\"${requirement}\"`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input.startsWith(this.requirement)) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        startsWith,\n        input,\n        \"start\",\n        `\"${input.slice(0, this.requirement.length)}\"`\n      );\n    }\n  };\n}\n\n// src/validations/ulid/ulid.ts\nfunction ulid(message) {\n  return {\n    type: \"ulid\",\n    expects: null,\n    async: false,\n    message,\n    requirement: ULID_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, ulid, input, \"ULID\");\n    }\n  };\n}\n\n// src/validations/url/url.ts\nfunction url(message) {\n  return {\n    type: \"url\",\n    expects: null,\n    async: false,\n    message,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    _parse(input) {\n      if (this.requirement(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, url, input, \"URL\");\n    }\n  };\n}\n\n// src/validations/uuid/uuid.ts\nfunction uuid(message) {\n  return {\n    type: \"uuid\",\n    expects: null,\n    async: false,\n    message,\n    requirement: UUID_REGEX,\n    _parse(input) {\n      if (this.requirement.test(input)) {\n        return actionOutput(input);\n      }\n      return actionIssue(this, uuid, input, \"UUID\");\n    }\n  };\n}\n\n// src/validations/value/value.ts\nfunction value(requirement, message) {\n  return {\n    type: \"value\",\n    expects: `${requirement instanceof Date ? requirement.toJSON() : stringify(requirement)}`,\n    async: false,\n    message,\n    requirement,\n    _parse(input) {\n      if (input <= this.requirement && input >= this.requirement) {\n        return actionOutput(input);\n      }\n      return actionIssue(\n        this,\n        value,\n        input,\n        \"value\",\n        input instanceof Date ? input.toJSON() : stringify(input)\n      );\n    }\n  };\n}\nexport {\n  BIC_REGEX,\n  BrandSymbol,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  OCTAL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  actionIssue,\n  actionOutput,\n  any,\n  anyAsync,\n  array,\n  arrayAsync,\n  bic,\n  bigint,\n  bigintAsync,\n  blob,\n  blobAsync,\n  boolean,\n  booleanAsync,\n  brand,\n  bytes,\n  coerce,\n  coerceAsync,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  dateAsync,\n  decimal,\n  defaultArgs,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  discriminatedUnion,\n  discriminatedUnionAsync,\n  email,\n  emoji,\n  endsWith,\n  enumAsync,\n  enumType,\n  enumTypeAsync,\n  enum_,\n  equal,\n  excludes,\n  fallback,\n  fallbackAsync,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  getDefault,\n  getDefaultAsync,\n  getDefaults,\n  getDefaultsAsync,\n  getFallback,\n  getFallbackAsync,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  hash,\n  hexColor,\n  hexadecimal,\n  i18n,\n  imei,\n  includes,\n  instance,\n  instanceAsync,\n  integer,\n  intersect,\n  intersection,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isLuhnAlgo,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  length,\n  literal,\n  literalAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  maxBytes,\n  maxLength,\n  maxRange,\n  maxSize,\n  maxValue,\n  merge,\n  mergeAsync,\n  mimeType,\n  minBytes,\n  minLength,\n  minRange,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  nanAsync,\n  nativeEnum,\n  nativeEnumAsync,\n  never,\n  neverAsync,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  nullAsync,\n  nullType,\n  nullTypeAsync,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  numberAsync,\n  object,\n  objectAsync,\n  octal,\n  omit,\n  omitAsync,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  partial,\n  partialAsync,\n  passthrough,\n  passthroughAsync,\n  pick,\n  pickAsync,\n  picklist,\n  picklistAsync,\n  pipeResult,\n  pipeResultAsync,\n  record,\n  recordAsync,\n  recursive,\n  recursiveAsync,\n  regex,\n  required,\n  requiredAsync,\n  restAndDefaultArgs,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  schemaIssue,\n  schemaResult,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  special,\n  specialAsync,\n  startsWith,\n  strict,\n  strictAsync,\n  string,\n  stringAsync,\n  stringify,\n  strip,\n  stripAsync,\n  symbol,\n  symbolAsync,\n  toCustom,\n  toCustomAsync,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toTrimmed,\n  toTrimmedEnd,\n  toTrimmedStart,\n  toUpperCase,\n  transform,\n  transformAsync,\n  tuple,\n  tupleAsync,\n  ulid,\n  undefinedAsync,\n  undefinedType,\n  undefinedTypeAsync,\n  undefined_,\n  union,\n  unionAsync,\n  unknown,\n  unknownAsync,\n  unwrap,\n  url,\n  useDefault,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  voidAsync,\n  voidType,\n  voidTypeAsync,\n  void_,\n  withDefault\n};\n","function n(n){return\"object\"==typeof n&&null!==n&&!Array.isArray(n)}function t(n){return null!==n&&Array.isArray(n)}function o(n){let o=\"\";for(const e of n)\"string\"!=typeof e?\"number\"!=typeof e?t(e)?(o&&(o+=\":\"),o+=\"\".concat(e.join(\",\"),\"}\")):e._key&&(o&&(o+=\":\"),o+=\"\".concat(e._key)):(o&&(o+=\":\"),o+=\"\".concat(e)):(o&&(o+=\".\"),o+=e);return o}const e=/^([A-Za-z]+):([0-9]+)$/,r=/^([A-Za-z]+):([0-9]+),([0-9]+)$/,c=/^([A-Za-z]+):([a-z0-9]+)$/;function u(n){const t=[];for(const o of n.split(\".\")){const n=e.exec(o);if(n){t.push(n[1],Number(n[2]));continue}const u=r.exec(o);if(u){t.push(u[1],[Number(u[2]),Number(u[3])]);continue}const s=c.exec(o);s?t.push(s[1],{_key:s[2]}):t.push(o)}return t}export{t as a,n as i,o as p,u};//# sourceMappingURL=urlStringToPath-53ZuVkUF.js.map\n","import{resolveMapping as t,getPublishedId as e,studioPath as r,jsonPathToStudioPath as n,resolvedKeyedSourcePath as o}from\"@sanity/client/csm\";import{string as a,minLength as i,optional as s,object as c,is as u,safeParse as p,parse as f}from\"valibot\";import{p as l,u as d,i as h,a as m}from\"./_chunks/urlStringToPath-53ZuVkUF.js\";function y(a,i,s,c){const{mapping:u,pathSuffix:p}=t(s,i)||{};if(!u)return;if(\"literal\"===u.source.type)return;if(\"unknown\"===u.source.type)return;const f=i.documents[u.source.document],l=i.paths[u.source.path];return f&&l?{baseUrl:a.baseUrl,workspace:a.workspace,tool:a.tool,type:f._type,id:e(f._id),path:r.toString(n(o({keyedResultPath:c,pathSuffix:p,sourceBasePath:l})))}:void 0}const k=a([i(1)]),_=s(k),b=c({id:k,path:k,type:_,baseUrl:k,workspace:_,tool:_}),w=c({origin:k,href:k,data:_});function v(t){return u(b,t)}function g(t){return u(w,t)}function j(t){const{id:n,path:o,baseUrl:a,tool:i,workspace:s,type:c}=t;if(!v(t))return;return[[\"id\",e(n)],[\"type\",c],[\"path\",l(r.fromString(o))],[\"base\",encodeURIComponent(a)],[\"workspace\",s],[\"tool\",i]].filter((([,t])=>!!t)).map((t=>t.join(\"=\"))).join(\";\")}function S(t){const e=t.split(\";\").reduce(((t,e)=>{const[n,o]=e.split(\"=\");if(!n||!o)return t;switch(n){case\"id\":t.id=o;break;case\"type\":t.type=o;break;case\"path\":t.path=r.toString(d(o));break;case\"base\":t.baseUrl=decodeURIComponent(o);break;case\"tool\":t.tool=o;break;case\"workspace\":t.workspace=o}return t}),{});if(v(e))return e}function U(t){try{return function(t){const e=p(b,t);if(e.success)return e.output;const r=p(w,t);if(r.success)try{const t=new URL(r.output.href,\"undefined\"==typeof document?\"https://example.com\":location.origin);return t.searchParams.size>0?f(b,Object.fromEntries(t.searchParams.entries())):r.output}catch(t){return console.error(\"Failed to parse sanity node\",t),r.output}}(JSON.parse(t))}catch{return S(t)}}const $=[\"_createdAt\",\"_dataset\",\"_id\",\"_key\",\"_originalId\",\"_projectId\",\"_ref\",\"_rev\",\"_strengthenOnPublish\",\"_type\",\"_updatedAt\",\"_weak\"];function O(t){if(void 0!==t){if(null===t)return null;if(h(e=t)&&\"sanity\"===e.$$type$$)return t.value;var e;if(m(t))return t.map((t=>O(t)));if(h(t))return Object.fromEntries(Object.entries(t).map((([t,e])=>$.includes(t)?[t,e]:[t,O(e)])));throw new Error(\"invalid wrapped value\")}}function P(t,e,o,a=[],i=[]){if(void 0!==e)return null===e?null:m(e)?e.map(((e,r)=>P(t,e,o,a.concat(r),i.concat(h(e)&&\"_key\"in e&&\"string\"==typeof e._key?{_key:e._key,_index:r}:r)))):h(e)?Object.fromEntries(Object.entries(e).map((([e,r])=>$.includes(e)?[e,r]:[e,P(t,r,o,a.concat(e),i.concat(e))]))):{$$type$$:\"sanity\",path:r.toString(n(a))||void 0,source:o?y(t,o,a,i):void 0,value:e}}export{U as decodeSanityNodeData,S as decodeSanityString,j as encodeSanityNodeData,g as isValidSanityLegacyNode,v as isValidSanityNode,y as resolveSanityNode,O as unwrapData,P as wrapData};//# sourceMappingURL=csm.js.map\n","export { VERCEL_STEGA_REGEX } from '@vercel/stega'\n\nexport const OVERLAY_ID = 'sanity-visual-editing'\n","export function findNonInlineElement(element: HTMLElement): HTMLElement | null {\n  const { display } = window.getComputedStyle(element)\n\n  if (display !== 'inline') return element\n\n  const parent = element.parentElement\n\n  if (!parent) return null\n\n  return findNonInlineElement(parent)\n}\n","import { vercelStegaDecode } from '@vercel/stega'\n\nimport { VERCEL_STEGA_REGEX } from '../constants'\n\n/**\n * JavaScript regexps are stateful. Have to reset lastIndex between runs to ensure consistent behaviour for the same string\n * @param input\n */\nexport function testVercelStegaRegex(input: string): boolean {\n  VERCEL_STEGA_REGEX.lastIndex = 0\n  return VERCEL_STEGA_REGEX.test(input)\n}\n\nexport function decodeStega(str: string, isAltText = false): string {\n  const decoded = vercelStegaDecode<{\n    origin?: string\n    href?: string\n    data?: unknown\n  }>(str)\n  if (!decoded || decoded.origin !== 'sanity.io') {\n    return ''\n  }\n  if (isAltText) {\n    decoded.href = decoded.href?.replace('.alt', '')\n  }\n  return JSON.stringify(decoded)\n}\n\nexport function testAndDecodeStega(str: string, isAltText = false): string {\n  if (testVercelStegaRegex(str)) {\n    return decodeStega(str, isAltText)\n  }\n  return ''\n}\n","import { decodeSanityNodeData } from '@sanity/visual-editing-helpers/csm'\n\nimport { OVERLAY_ID } from '../constants'\nimport { _ResolvedElement, SanityNode, SanityNodeLegacy } from '../types'\nimport { findNonInlineElement } from './findNonInlineElement'\nimport { testAndDecodeStega } from './stega'\n\nconst isElementNode = (node: ChildNode): node is HTMLElement =>\n  node.nodeType === Node.ELEMENT_NODE\n\nconst isImgElement = (el: HTMLElement): el is HTMLImageElement =>\n  el.tagName === 'IMG'\n\nconst isTimeElement = (el: HTMLElement): el is HTMLTimeElement =>\n  el.tagName === 'TIME'\n\nfunction isSanityNode(node: SanityNode | SanityNodeLegacy): node is SanityNode {\n  return 'path' in node\n}\n\n/**\n * Finds commonality between two document paths strings\n * @param first First path to compare\n * @param second Second path to compare\n * @returns A common path\n */\nexport function findCommonPath(first: string, second: string): string {\n  let firstParts = first.split('.')\n  let secondParts = second.split('.')\n  const maxLength = Math.min(firstParts.length, secondParts.length)\n  firstParts = firstParts.slice(0, maxLength).reverse()\n  secondParts = secondParts.slice(0, maxLength).reverse()\n\n  return firstParts\n    .reduce(\n      (parts, part, i) => (part === secondParts[i] ? [...parts, part] : []),\n      [] as string[],\n    )\n    .reverse()\n    .join('.')\n}\n\n/**\n * Returns common Sanity node data from multiple nodes\n * If doocument paths are present, tries to resolve a common path\n * @param nodes An array of Sanity nodes\n * @returns A single sanity node or undefined\n * @internal\n */\nexport function findCommonSanityData(\n  nodes: (SanityNode | SanityNodeLegacy)[],\n): SanityNode | SanityNodeLegacy | undefined {\n  // If there are no nodes, or inconsistent node types\n  if (\n    !nodes.length ||\n    !nodes.map((n) => isSanityNode(n)).every((n, _i, arr) => n === arr[0])\n  ) {\n    return undefined\n  }\n  // If legacy nodes, return first match (no common pathfinding)\n  if (!isSanityNode(nodes[0])) return nodes[0]\n\n  const sanityNodes = nodes.filter(isSanityNode)\n  let common: SanityNode | undefined = nodes[0]\n\n  const consistentValueKeys: Array<keyof SanityNode> = [\n    'projectId',\n    'dataset',\n    'id',\n    'baseUrl',\n    'workspace',\n    'tool',\n  ]\n  for (let i = 1; i < sanityNodes.length; i++) {\n    const node = sanityNodes[i]\n    if (consistentValueKeys.some((key) => node[key] !== common?.[key])) {\n      common = undefined\n      break\n    }\n\n    common.path = findCommonPath(common.path, node.path)\n  }\n\n  return common\n}\n\n/**\n * Finds nodes containing sanity specific data\n * @param el - A parent element to traverse\n * @returns An array of objects, each containing an HTML element and decoded sanity data\n * @internal\n */\nexport function findSanityNodes(\n  el: HTMLElement | ChildNode | { childNodes: HTMLElement[] },\n): _ResolvedElement[] {\n  const elements: _ResolvedElement[] = []\n\n  function addElement(element: HTMLElement, data: string) {\n    const sanity = decodeSanityNodeData(data)\n    if (!sanity) {\n      return\n    }\n\n    const measureElement = findNonInlineElement(element)\n    if (!measureElement) {\n      return\n    }\n\n    elements.push({\n      elements: {\n        element,\n        measureElement,\n      },\n      sanity,\n    })\n  }\n\n  if (el) {\n    for (const node of el.childNodes) {\n      const { nodeType, parentElement, textContent } = node\n      // If an edit target is found, find common paths\n      if (isElementNode(node) && node.dataset?.sanityEditTarget !== undefined) {\n        const nodesInTarget = findSanityNodes(node).map(({ sanity }) => sanity)\n        // If there are inconsistent node types, continue\n        if (\n          !nodesInTarget\n            .map((n) => isSanityNode(n))\n            .every((n, _i, arr) => n === arr[0])\n        ) {\n          continue\n        }\n\n        const commonData = findCommonSanityData(nodesInTarget)\n\n        if (commonData) {\n          elements.push({\n            elements: {\n              element: node,\n              measureElement: node,\n            },\n            sanity: commonData,\n          })\n        }\n\n        // Check non-empty, child-only text nodes for stega strings\n      } else if (nodeType === Node.TEXT_NODE && parentElement && textContent) {\n        const data = testAndDecodeStega(textContent)\n        if (!data) continue\n        addElement(parentElement, data)\n      }\n      // Check element nodes for data attributes, alt tags, etc\n      else if (isElementNode(node)) {\n        // Do not traverse script tags\n        // Do not traverse the visual editing overlay\n        if (node.tagName === 'SCRIPT' || node.id === OVERLAY_ID) {\n          continue\n        }\n\n        // Prefer elements with explicit data attributes\n        if (node.dataset?.sanity) {\n          addElement(node, node.dataset.sanity)\n        }\n        // Look for legacy sanity data attributes\n        else if (node.dataset?.sanityEditInfo) {\n          addElement(node, node.dataset.sanityEditInfo)\n        } else if (isImgElement(node)) {\n          const data = testAndDecodeStega(node.alt, true)\n          if (!data) continue\n          addElement(node, data)\n          // No need to recurse for img elements\n          continue\n        } else if (isTimeElement(node)) {\n          const data = testAndDecodeStega(node.dateTime, true)\n          addElement(node, data)\n        }\n\n        elements.push(...findSanityNodes(node))\n      }\n    }\n  }\n  return elements\n}\n","import { OverlayRect } from '../types'\n\nexport function getRect(element: Element): OverlayRect {\n  const domRect = element.getBoundingClientRect()\n\n  const rect = {\n    x: domRect.x + scrollX,\n    y: domRect.y + scrollY,\n    w: domRect.width,\n    h: domRect.height,\n  }\n\n  return rect\n}\n","import type { Root } from 'react-dom/client'\n\nimport { OVERLAY_ID } from '../constants'\nimport { HistoryAdapter } from '../types'\n\n/**\n * Cleanup function used when e.g. unmounting\n * @public\n */\nexport type DisableVisualEditing = () => void\n\n/**\n * @public\n */\nexport interface VisualEditingOptions {\n  /**\n   * The history adapter is used for Sanity Presentation to navigate URLs in the preview frame.\n   */\n  history?: HistoryAdapter\n  /**\n   * The CSS z-index on the root node that renders overlays, tweak it accordingly to what layout you have.\n   */\n  zIndex?: string | number\n}\n\nlet node: HTMLElement | null = null\nlet root: Root | null = null\nlet cleanup: number | null = null\n\n/**\n * Enables Visual Editing overlay in a page with sourcemap encoding.\n *\n * This will overlay UI on hovered elements that deep-links to Sanity Studio.\n * @public\n */\nexport function enableVisualEditing(\n  options: VisualEditingOptions = {},\n): DisableVisualEditing {\n  if (cleanup) clearTimeout(cleanup)\n  const controller = new AbortController()\n\n  // Lazy load everything needed to render the app\n  Promise.all([import('react-dom/client'), import('./Overlays')]).then(\n    ([reactClient, { Overlays }]) => {\n      if (controller.signal.aborted) return\n\n      const { history, zIndex } = options\n\n      if (!node) {\n        node = document.createElement('div')\n        node.id = OVERLAY_ID\n        document.body.appendChild(node)\n      }\n\n      if (!root) {\n        const { createRoot } =\n          'default' in reactClient ? reactClient.default : reactClient\n        root = createRoot(node)\n      }\n\n      root.render(<Overlays history={history} zIndex={zIndex} />)\n    },\n  )\n\n  return () => {\n    controller.abort()\n    // Handle React StrictMode, delay cleanup for a second in case it's a rerender\n    cleanup = window.setTimeout(() => {\n      if (root) {\n        root.unmount()\n        root = null\n      }\n      if (node) {\n        document.body.removeChild(node)\n        node = null\n      }\n    }, 1000)\n  }\n}\n","import { v4 as uuid } from 'uuid'\n\nimport type {\n  _EventHandlers,\n  _OverlayElement,\n  _ResolvedElement,\n  OverlayController,\n  OverlayOptions,\n} from './types'\nimport { findSanityNodes } from './util/findSanityNodes'\nimport { getRect } from './util/getRect'\n\n/**\n * Creates a controller which dispatches overlay related events\n *\n * @param handler - Dispatched event handler\n * @param overlayElement - Parent element containing rendered overlay elements\n * @public\n */\nexport function createOverlayController({\n  handler,\n  overlayElement,\n  preventDefault,\n}: OverlayOptions): OverlayController {\n  let activated = false\n  // Map for getting element by ID\n  const elementIdMap = new Map<string, HTMLElement>()\n  // WeakMap for getting data by element\n  const elementsMap = new WeakMap<HTMLElement, _OverlayElement>()\n  // Set for iterating over elements\n  const elementSet = new Set<HTMLElement>()\n  // Weakmap keyed by measureElement to find associated element\n  const measureElements = new WeakMap<HTMLElement, HTMLElement>()\n\n  let ro: ResizeObserver\n  let io: IntersectionObserver\n  let mo: MutationObserver\n\n  // The `hoverStack` is used as a container for tracking which elements are hovered at any time.\n  // The browser supports hovering multiple nested elements simultanously, but we only want to\n  // highlight the \"outer most\" element.\n  //\n  // This is how it works:\n  // - Whenever the mouse enters an element, we add it to the stack.\n  // - Whenever the mouse leaves an element, we remove it from the stack.\n  //\n  // When we want to know which element is currently hovered, we take the element at the top of the\n  // stack. Since JavaScript does not have a Stack type, we use an array and take the last element.\n  let hoverStack: HTMLElement[] = []\n  const getHoveredElement = () =>\n    hoverStack[hoverStack.length - 1] as HTMLElement | undefined\n\n  function addEventHandlers(el: HTMLElement, handlers: _EventHandlers) {\n    el.addEventListener('click', handlers.click, {\n      capture: true,\n    })\n    // We listen for the initial mousemove event, in case the overlay is enabled whilst the cursor is already over an element\n    // mouseenter and mouseleave listeners are attached within this handler\n    el.addEventListener('mousemove', handlers.mousemove, {\n      once: true,\n      capture: true,\n    })\n    // Listen for mousedown in case we need to prevent default behavior\n    el.addEventListener('mousedown', handlers.mousedown, {\n      capture: true,\n    })\n  }\n\n  function removeEventHandlers(el: HTMLElement, handlers: _EventHandlers) {\n    el.removeEventListener('click', handlers.click, {\n      capture: true,\n    })\n    el.removeEventListener('mousemove', handlers.mousemove, {\n      capture: true,\n    })\n    el.removeEventListener('mousedown', handlers.mousedown, {\n      capture: true,\n    })\n    el.removeEventListener('mouseenter', handlers.mouseenter)\n    el.removeEventListener('mouseleave', handlers.mouseleave)\n  }\n\n  /**\n   * Executed when element enters the viewport\n   * Enables an elements event handlers\n   */\n  function activateElement({\n    id,\n    elements,\n    handlers,\n    sanity,\n  }: _OverlayElement) {\n    const { element, measureElement } = elements\n    addEventHandlers(element, handlers)\n    ro.observe(measureElement)\n    handler({\n      type: 'element/activate',\n      id,\n      rect: getRect(element),\n      sanity,\n    })\n  }\n\n  /**\n   * Executed when element leaves the viewport\n   * Disables an elements event handlers\n   */\n  function deactivateElement({ id, elements, handlers }: _OverlayElement) {\n    const { element, measureElement } = elements\n    removeEventHandlers(element, handlers)\n    ro.unobserve(measureElement)\n    // Scrolling from a hovered element will not trigger mouseleave event, so filter the stack\n    hoverStack = hoverStack.filter((el) => el !== element)\n    handler({\n      type: 'element/deactivate',\n      id,\n    })\n  }\n\n  /**\n   * Stores an elements DOM node and decoded sanity data in state and sets up event handlers\n   */\n  function registerElement({ elements, sanity }: _ResolvedElement) {\n    const { element, measureElement } = elements\n\n    const eventHandlers: _EventHandlers = {\n      click(event) {\n        const target = event.target as HTMLElement | null\n        if (element === getHoveredElement() && element.contains(target)) {\n          if (preventDefault) {\n            event.preventDefault()\n            event.stopPropagation()\n          }\n          handler({\n            type: 'element/click',\n            id,\n            sanity,\n          })\n        }\n      },\n      mousedown(event) {\n        // prevent iframe from taking focus\n        event.preventDefault()\n      },\n      mousemove(event) {\n        eventHandlers.mouseenter(event)\n        const el = event.currentTarget as HTMLElement | null\n        if (el) {\n          el.addEventListener('mouseenter', eventHandlers.mouseenter)\n          el.addEventListener('mouseleave', eventHandlers.mouseleave)\n        }\n      },\n      mouseenter() {\n        hoverStack.push(element)\n        handler({\n          type: 'element/mouseenter',\n          id,\n          rect: getRect(element),\n        })\n      },\n      mouseleave(e) {\n        function leave() {\n          hoverStack.pop()\n          const hoveredElement = getHoveredElement()\n\n          handler({\n            type: 'element/mouseleave',\n            id,\n          })\n\n          if (hoveredElement) {\n            const overlayElement = elementsMap.get(hoveredElement)\n            if (overlayElement) {\n              handler({\n                type: 'element/mouseenter',\n                id: overlayElement.id,\n                rect: getRect(hoveredElement),\n              })\n            }\n          }\n        }\n\n        /**\n         * If moving to an element within the overlay which handles pointer events, attach a new\n         * event handler to that element and defer the original leave event\n         */\n        const { relatedTarget } = e\n        const isInteractiveOverlayElement =\n          relatedTarget instanceof HTMLElement &&\n          overlayElement.contains(relatedTarget)\n\n        if (isInteractiveOverlayElement) {\n          const deferredLeave = () => {\n            leave()\n            relatedTarget.removeEventListener('mouseleave', deferredLeave)\n          }\n          relatedTarget.addEventListener('mouseleave', deferredLeave)\n          return\n        }\n\n        leave()\n      },\n    }\n\n    const id = uuid()\n    const sanityNode = {\n      id,\n      elements,\n      sanity,\n      handlers: eventHandlers,\n    }\n    elementSet.add(element)\n    measureElements.set(measureElement, element)\n    elementIdMap.set(id, element)\n    elementsMap.set(element, sanityNode)\n\n    io.observe(element)\n    ro.observe(measureElement)\n\n    handler({\n      type: 'element/register',\n      id,\n      rect: getRect(element),\n      sanity,\n    })\n\n    activateElement(sanityNode)\n  }\n\n  function registerElements(node: HTMLElement | { childNodes: HTMLElement[] }) {\n    const sanityNodes = findSanityNodes(node)\n    for (const sanityNode of sanityNodes) {\n      if (\n        sanityNode.elements.element instanceof HTMLElement &&\n        !elementsMap.has(sanityNode.elements.element)\n      ) {\n        registerElement(sanityNode)\n      }\n    }\n  }\n\n  function unregisterElement(element: HTMLElement) {\n    const overlayElement = elementsMap.get(element)\n    if (overlayElement) {\n      const { id, handlers } = overlayElement\n      removeEventHandlers(element, handlers)\n      ro.unobserve(element)\n      elementsMap.delete(element)\n      elementSet.delete(element)\n      elementIdMap.delete(id)\n      handler({\n        type: 'element/unregister',\n        id,\n      })\n    }\n  }\n\n  // Mutations\n  function handleMutation(mutations: MutationRecord[]) {\n    const needsUpdate = !!mutations.filter((mutation) => {\n      const node: Node | null = mutation.target\n\n      // Ignore overlay elements and container\n      if (node === overlayElement || overlayElement.contains(node)) {\n        return false\n      }\n\n      if (node instanceof HTMLElement) {\n        if (elementsMap.has(node)) {\n          const sanityNodes = findSanityNodes({ childNodes: [node] })\n          // Check existing nodes are still valid\n          if (!sanityNodes.length) {\n            unregisterElement(node)\n          }\n        } else {\n          registerElements({ childNodes: [node] })\n        }\n      }\n\n      return true\n    }).length\n\n    if (needsUpdate) {\n      for (const element of elementSet) {\n        if (element.isConnected) {\n          updateRect(element)\n        } else {\n          unregisterElement(element)\n        }\n      }\n    }\n  }\n\n  /**\n\n   * Dispatches an event containing the size and position (rect) of an element\n   * @param el - Element to dispatch rect information for\n   */\n  function updateRect(el: HTMLElement) {\n    const overlayElement = elementsMap.get(el)\n    if (overlayElement) {\n      handler({\n        type: 'element/updateRect',\n        id: overlayElement.id,\n        rect: getRect(el),\n      })\n    }\n  }\n\n  function handleResize(entries: ResizeObserverEntry[]) {\n    for (const entry of entries) {\n      const target = entry.target\n\n      if (target instanceof HTMLElement) {\n        const element = measureElements.get(target)\n        if (!element) return\n        updateRect(element)\n      }\n    }\n  }\n\n  function handleIntersection(entries: IntersectionObserverEntry[]) {\n    for (const entry of entries) {\n      const { target } = entry\n      const match = target instanceof HTMLElement && elementsMap.get(target)\n      if (!match) continue\n      if (entry.isIntersecting) {\n        activateElement(match)\n      } else {\n        deactivateElement(match)\n      }\n    }\n  }\n\n  function handleBlur() {\n    hoverStack = []\n    handler({\n      type: 'overlay/blur',\n    })\n  }\n\n  function handleWindowResize() {\n    for (const element of elementSet) {\n      updateRect(element)\n    }\n  }\n\n  function handleWindowScroll(event: Event) {\n    const { target } = event\n\n    if (target === window.document || !(target instanceof HTMLElement)) {\n      return\n    }\n\n    for (const element of elementSet) {\n      if (target.contains(element)) {\n        updateRect(element)\n      }\n    }\n  }\n\n  function deactivate() {\n    if (!activated) return\n    window.removeEventListener('click', handleBlur)\n    window.removeEventListener('resize', handleWindowResize)\n    window.removeEventListener('scroll', handleWindowScroll)\n    io.disconnect()\n    mo.disconnect()\n    ro.disconnect()\n\n    elementSet.forEach((element) => {\n      unregisterElement(element)\n    })\n\n    elementIdMap.clear()\n    elementSet.clear()\n\n    hoverStack = []\n    activated = false\n    handler({\n      type: 'overlay/deactivate',\n    })\n  }\n\n  function activate() {\n    if (activated) return\n    window.addEventListener('click', handleBlur)\n    window.addEventListener('resize', handleWindowResize)\n    window.addEventListener('scroll', handleWindowScroll, {\n      capture: true,\n      passive: true,\n    })\n    io = new IntersectionObserver(handleIntersection, {\n      threshold: 0.3,\n    })\n    ro = new ResizeObserver(handleResize)\n    mo = new MutationObserver(handleMutation)\n    mo.observe(document.body, {\n      attributes: true,\n      characterData: true,\n      childList: true,\n      subtree: true,\n    })\n\n    registerElements(document.body)\n    activated = true\n    handler({\n      type: 'overlay/activate',\n    })\n  }\n\n  window.document.fonts.ready.then(() => {\n    for (const element of elementSet) {\n      updateRect(element)\n    }\n  })\n\n  activate()\n\n  return {\n    activate,\n    deactivate,\n  }\n}\n"],"names":["stega","require","jsxRuntime","getRandomValues","rnds8","Uint8Array","rng","crypto","bind","Error","byteToHex","i","push","toString","slice","native","randomUUID","v4","options","buf","offset","rnds","random","arr","unsafeStringify","rePropName","reKeySegment","reIndexTuple","isIndexSegment","segment","test","isKeySegment","trim","isIndexTuple","Array","isArray","length","from","to","path","reduce","target","segmentType","concat","separator","_key","JSON","stringify","fromString","segments","match","map","parsePathSegment","Number","replace","parseIndexSegment","parseKeySegment","split","seg","parseIndexTupleSegment","studioPath","Object","freeze","__proto__","get","obj","defaultVal","select","acc","find","item","DRAFTS_PREFIX","store","store2","store3","store4","ValiError","issues","constructor","super","message","this","name","defaultArgs","arg1","arg2","getGlobalConfig","config","lang","abortEarly","abortPipeEarly","skipPipe","i18n","context","reference","issue","getSpecificMessage","type","getGlobalMessage","schemaResult","typed","output","input","getPrototypeOf","pipeIssue","received","schemaIssue2","reason","expected","expects","label","requirement","pipeResult","pipe","action","result","_parse","actionIssue2","schemaIssue","other","object","entries","arg3","arg4","rest","error2","pipe2","error","restAndDefaultArgs","cachedEntries","async","key","schema","value2","pathItem","origin","value","unshift","safeParse","success","data","t","n","e","r","c","k","string","a","minLength","actionIssue","_","wrapped","default","default_","override","b","id","baseUrl","workspace","tool","w","href","v","S","o","exec","u","s","d","decodeURIComponent","U","p","URL","document","location","searchParams","size","f","fromEntries","console","parse","OVERLAY_ID","findNonInlineElement","element","display","window","getComputedStyle","parent","parentElement","testAndDecodeStega","str","isAltText","VERCEL_STEGA_REGEX","lastIndex","_a","decoded","vercelStegaDecode","decodeStega","isElementNode","node","nodeType","Node","ELEMENT_NODE","isImgElement","el","tagName","isTimeElement","isSanityNode","findCommonPath","first","second","firstParts","secondParts","maxLength","Math","min","reverse","parts","part","join","findCommonSanityData","nodes","every","_i","sanityNodes","filter","common","consistentValueKeys","some","findSanityNodes","_b","_c","elements","addElement","sanity","decodeSanityNodeData","measureElement","childNodes","textContent","dataset","sanityEditTarget","nodesInTarget","commonData","TEXT_NODE","sanityEditInfo","alt","dateTime","getRect","domRect","getBoundingClientRect","x","scrollX","y","scrollY","width","h","height","root","cleanup","exports","handler","overlayElement","preventDefault","activated","elementIdMap","Map","elementsMap","WeakMap","elementSet","Set","measureElements","ro","io","mo","hoverStack","getHoveredElement","removeEventHandlers","handlers","removeEventListener","click","capture","mousemove","mousedown","mouseenter","mouseleave","activateElement","addEventListener","once","addEventHandlers","observe","rect","deactivateElement","unobserve","registerElement","eventHandlers","event","contains","stopPropagation","currentTarget","leave","pop","hoveredElement","relatedTarget","HTMLElement","deferredLeave","uuid","sanityNode","add","set","registerElements","has","unregisterElement","delete","handleMutation","mutations","needsUpdate","mutation","isConnected","updateRect","handleResize","entry","handleIntersection","isIntersecting","handleBlur","handleWindowResize","handleWindowScroll","activate","passive","IntersectionObserver","threshold","ResizeObserver","MutationObserver","body","attributes","characterData","childList","subtree","fonts","ready","then","deactivate","disconnect","forEach","clear","_workspace","_tool","_id","endsWith","startsWith","getPublishedId","stringifiedPath","_index","jsonPathToStudioPath","URLSearchParams","routerParams","encodeURIComponent","clearTimeout","controller","AbortController","Promise","all","import","reactClient","Overlays","signal","aborted","history","zIndex","createElement","appendChild","createRoot","render","jsx","abort","setTimeout","unmount","removeChild"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5]}