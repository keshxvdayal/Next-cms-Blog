{"version":3,"file":"index.js","sources":["../src/errors.ts","../src/signature.ts","../src/middleware.ts"],"sourcesContent":["/**\n * Error types used on signature errors.\n * Includes `type` and `statusCode` properties.\n *\n * @public\n */\nexport type WebhookSignatureError = WebhookSignatureValueError | WebhookSignatureFormatError\n\n/**\n * Error thrown when the signature value does not match the expected value.\n *\n * @public\n */\nexport class WebhookSignatureValueError extends Error {\n  public type = 'WebhookSignatureValueError'\n  public statusCode = 401\n}\n\n/**\n * Error thrown when the signature format is invalid.\n * This can happen when the signature is not a string or is not in the format of `t=<timestamp>,v=<signature>`.\n * This error is also thrown when the timestamp is not a number or is not within the tolerance time.\n *\n * @public\n */\nexport class WebhookSignatureFormatError extends Error {\n  public type = 'WebhookSignatureFormatError'\n  public statusCode = 400\n}\n\n/**\n * Checks whether or not the given error is a signature error.\n *\n * @param error - The error to check.\n * @returns `true` if the error is a signature error, otherwise `false`.\n * @public\n */\nexport function isSignatureError(error: unknown): error is WebhookSignatureError {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    'type' in error &&\n    ['WebhookSignatureValueError', 'WebhookSignatureFormatError'].includes(\n      (error as WebhookSignatureError).type,\n    )\n  )\n}\n","import {WebhookSignatureFormatError, WebhookSignatureValueError} from './errors'\nimport type {DecodedSignature, ConnectLikeRequest} from './types'\n\n/**\n * We didn't send signed payloads prior to 2021 (2021-01-01T00:00:00.000Z)\n */\nconst MINIMUM_TIMESTAMP = 1609459200000\n\nconst SIGNATURE_HEADER_REGEX = /^t=(\\d+)[, ]+v1=([^, ]+)$/\n\n/**\n * The name of the header that contains the signature.\n *\n * @public\n */\nexport const SIGNATURE_HEADER_NAME = 'sanity-webhook-signature'\n\n/**\n * Asserts that the given signature is valid.\n * Throws an error if the signature is invalid.\n *\n * @param stringifiedPayload - The stringified payload to verify - should be straight from the request, not a re-encoded JSON string, as this in certain cases will yield mismatches due to inconsistent encoding.\n * @param signature - The signature to verify against\n * @param secret - The secret to use for verifying the signature\n * @public\n */\nexport async function assertValidSignature(\n  stringifiedPayload: string,\n  signature: string,\n  secret: string,\n): Promise<void> {\n  const {timestamp} = decodeSignatureHeader(signature)\n  const encoded = await encodeSignatureHeader(stringifiedPayload, timestamp, secret)\n  if (signature !== encoded) {\n    throw new WebhookSignatureValueError('Signature is invalid')\n  }\n}\n\n/**\n * Checks if the given signature is valid.\n *\n * @param stringifiedPayload - The stringified payload to verify - should be straight from the request, not a re-encoded JSON string, as this in certain cases will yield mismatches due to inconsistent encoding.\n * @param signature - The signature to verify against\n * @param secret - The secret to use for verifying the signature\n * @returns A promise that resolves to `true` if the signature is valid, `false` otherwise.\n * @public\n */\nexport async function isValidSignature(\n  stringifiedPayload: string,\n  signature: string,\n  secret: string,\n): Promise<boolean> {\n  try {\n    await assertValidSignature(stringifiedPayload, signature, secret)\n    return true\n  } catch (err) {\n    return false\n  }\n}\n\n/**\n * Asserts that the given request is valid.\n * Throws an error if the request is invalid.\n *\n * @param request - The Connect/Express-like request to verify\n * @param secret - The secret to use for verifying the signature\n * @public\n */\nexport async function assertValidRequest(\n  request: ConnectLikeRequest,\n  secret: string,\n): Promise<void> {\n  const signature = request.headers[SIGNATURE_HEADER_NAME]\n  if (Array.isArray(signature)) {\n    throw new WebhookSignatureFormatError('Multiple signature headers received')\n  }\n\n  if (typeof signature !== 'string') {\n    throw new WebhookSignatureValueError('Request contained no signature header')\n  }\n\n  if (typeof request.body === 'undefined') {\n    throw new WebhookSignatureFormatError('Request contained no parsed request body')\n  }\n\n  if (typeof request.body === 'string' || Buffer.isBuffer(request.body)) {\n    await assertValidSignature(request.body.toString('utf8'), signature, secret)\n  } else {\n    throw new Error(\n      '[@sanity/webhook] `request.body` was not a string/buffer - this can lead to invalid signatures. See the [migration docs](https://github.com/sanity-io/webhook-toolkit#from-parsed-to-unparsed-body) for details on how to fix this.',\n    )\n  }\n}\n\n/**\n * Checks if the given request is valid.\n *\n * @param request - The Connect/Express-like request to verify\n * @param secret - The secret to use for verifying the signature\n * @returns Promise that resolves to `true` if the request is valid, `false` otherwise.\n * @public\n */\nexport async function isValidRequest(\n  request: ConnectLikeRequest,\n  secret: string,\n): Promise<boolean> {\n  try {\n    await assertValidRequest(request, secret)\n    return true\n  } catch (err) {\n    return false\n  }\n}\n\n/**\n * Encodes a signature header for the given payload and timestamp.\n *\n * @param stringifiedPayload - The stringified payload to verify - should be straight from the request, not a re-encoded JSON string, as this in certain cases will yield mismatches due to inconsistent encoding.\n * @param timestamp - The timestamp to use for the signature\n * @param secret - The secret to use for verifying the signature\n * @returns A promise that resolves to the encoded signature header\n * @public\n */\nexport async function encodeSignatureHeader(\n  stringifiedPayload: string,\n  timestamp: number,\n  secret: string,\n): Promise<string> {\n  const signature = await createHS256Signature(stringifiedPayload, timestamp, secret)\n  return `t=${timestamp},v1=${signature}`\n}\n\n/**\n * Decode a signature header into a timestamp and hashed payload.\n *\n * @param signaturePayload - The signature header to decode\n * @returns An object with the decoded timestamp and hashed payload\n * @public\n */\nexport function decodeSignatureHeader(signaturePayload: string): DecodedSignature {\n  if (!signaturePayload) {\n    throw new WebhookSignatureFormatError('Missing or empty signature header')\n  }\n\n  const [, timestamp, hashedPayload] = signaturePayload.trim().match(SIGNATURE_HEADER_REGEX) || []\n  if (!timestamp || !hashedPayload) {\n    throw new WebhookSignatureFormatError('Invalid signature payload format')\n  }\n\n  return {\n    timestamp: parseInt(timestamp, 10),\n    hashedPayload,\n  }\n}\n\n/**\n * Creates a HS256 signature for the given payload and timestamp.\n *\n * @param stringifiedPayload - The stringified payload to verify - should be straight from the request, not a re-encoded JSON string, as this in certain cases will yield mismatches due to inconsistent encoding.\n * @param timestamp - The timestamp to use for the signature\n * @param secret - The secret to use for verifying the signature\n * @returns A promise that resolves to the encoded signature\n * @internal\n */\nasync function createHS256Signature(\n  stringifiedPayload: string,\n  timestamp: number,\n  secret: string,\n): Promise<string> {\n  if (!secret || typeof secret !== 'string') {\n    throw new WebhookSignatureFormatError('Invalid secret provided')\n  }\n\n  if (!stringifiedPayload) {\n    throw new WebhookSignatureFormatError('Can not create signature for empty payload')\n  }\n\n  if (typeof stringifiedPayload !== 'string') {\n    throw new WebhookSignatureFormatError('Payload must be a JSON-encoded string')\n  }\n\n  if (typeof timestamp !== 'number' || isNaN(timestamp) || timestamp < MINIMUM_TIMESTAMP) {\n    throw new WebhookSignatureFormatError(\n      'Invalid signature timestamp, must be a unix timestamp with millisecond precision',\n    )\n  }\n\n  const enc = new TextEncoder()\n  const key = await crypto.subtle.importKey(\n    'raw',\n    enc.encode(secret),\n    {name: 'HMAC', hash: 'SHA-256'},\n    false,\n    ['sign'],\n  )\n  const signaturePayload = `${timestamp}.${stringifiedPayload}`\n  const signature = await crypto.subtle.sign('HMAC', key, enc.encode(signaturePayload))\n\n  // Encode as base64url\n  let signatureArray = Array.from(new Uint8Array(signature))\n  return btoa(String.fromCharCode.apply(null, signatureArray))\n    .replace(/\\+/g, '-') // Replace '+' with '-'\n    .replace(/\\//g, '_') // Replace '/' with '_'\n    .replace(/=+$/, '') // Remove padding\n}\n","import type {RequestHandler} from 'express'\nimport {isSignatureError} from './errors'\nimport {assertValidRequest} from './signature'\n\n/**\n * Options for the `requireSignedRequest` middleware\n *\n * @public\n */\nexport interface SignatureMiddlewareOptions {\n  /**\n   * The secret to use for verifying the signature\n   */\n  secret: string\n\n  /**\n   * Whether or not to parse the request body as JSON on success (assigns it to `request.body`).\n   * Default: `true`\n   */\n  parseBody?: boolean\n\n  /**\n   * Whether or not to respond with an error when the signature is invalid.\n   * If `false`, it will call the `next` function with the error instead.\n   * Default: `true`\n   */\n  respondOnError?: boolean\n}\n\n/**\n * Express/Connect style middleware that verifies the signature of a request.\n * Should be added _after_ a body parser that parses the request body to _text_, not parsed JSON.\n *\n * @example\n * ```ts\n * import express from 'express'\n * import bodyParser from 'body-parser'\n * import {requireSignedRequest} from '@sanity/webhook'\n *\n * express()\n *   .use(bodyParser.text({type: 'application/json'}))\n *   .post(\n *     '/hook',\n *     requireSignedRequest({secret: process.env.MY_WEBHOOK_SECRET, parseBody: true}),\n *     function myRequestHandler(req, res) {\n *       // Note that `req.body` is now a parsed version, set `parseBody` to `false`\n *       // if you want the raw text version of the request body\n *     },\n *   )\n *   .listen(1337)\n * ```\n *\n * @param options - Options for the middleware\n * @returns A middleware function\n * @public\n */\nexport function requireSignedRequest(options: SignatureMiddlewareOptions): RequestHandler {\n  const parseBody = typeof options.parseBody === 'undefined' ? true : options.parseBody\n  const respondOnError =\n    typeof options.respondOnError === 'undefined' ? true : options.respondOnError\n\n  return async function ensureSignedRequest(request, response, next) {\n    try {\n      await assertValidRequest(request, options.secret)\n      if (parseBody && typeof request.body === 'string') {\n        request.body = JSON.parse(request.body)\n      }\n      next()\n    } catch (err) {\n      if (!respondOnError || !isSignatureError(err)) {\n        next(err)\n        return\n      }\n\n      response.status(err.statusCode).json({message: err.message})\n    }\n  }\n}\n"],"names":["WebhookSignatureValueError","Error","type","statusCode","WebhookSignatureFormatError","isSignatureError","error","includes","MINIMUM_TIMESTAMP","SIGNATURE_HEADER_REGEX","SIGNATURE_HEADER_NAME","assertValidSignature","stringifiedPayload","signature","secret","timestamp","decodeSignatureHeader","encoded","encodeSignatureHeader","isValidSignature","err","assertValidRequest","request","headers","Array","isArray","body","Buffer","isBuffer","toString","isValidRequest","createHS256Signature","signaturePayload","hashedPayload","trim","match","parseInt","isNaN","enc","TextEncoder","key","crypto","subtle","importKey","encode","name","hash","sign","signatureArray","from","Uint8Array","btoa","String","fromCharCode","apply","replace","requireSignedRequest","options","parseBody","respondOnError","ensureSignedRequest","response","next","JSON","parse","status","json","message"],"mappings":"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"}